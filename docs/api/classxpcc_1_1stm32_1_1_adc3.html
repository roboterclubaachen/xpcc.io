<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>xpcc: xpcc::stm32::Adc3 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xpcc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="modules.html"><span>API</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="../index.html"><span>General</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classxpcc_1_1stm32_1_1_adc3.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classxpcc_1_1stm32_1_1_adc3-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">xpcc::stm32::Adc3 Class Reference<div class="ingroups"><a class="el" href="group__architecture.html">Architecture</a> &raquo; <a class="el" href="group__platform.html">Supported Platforms</a> &raquo; <a class="el" href="group__stm32f407vg.html">Stm32f407vg</a> &raquo; <a class="el" href="group__stm32f407vg__adc.html">ADC</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Analog/Digital-Converter module (ADC3).  
 <a href="classxpcc_1_1stm32_1_1_adc3.html#details">More...</a></p>

<p><code>#include &lt;driver/adc/stm32/adc_3.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xpcc::stm32::Adc3:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxpcc_1_1stm32_1_1_adc3.png" usemap="#xpcc::stm32::Adc3_map" alt=""/>
  <map id="xpcc::stm32::Adc3_map" name="xpcc::stm32::Adc3_map">
<area href="classxpcc_1_1_adc.html" title="Basic interface of an ADC. " alt="xpcc::Adc" shape="rect" coords="0,56,160,80"/>
<area href="classxpcc_1_1_peripheral.html" title="Peripheral class. " alt="xpcc::Peripheral" shape="rect" coords="0,0,160,24"/>
<area href="classxpcc_1_1stm32_1_1_adc_interrupt3.html" title="ADC Interrupt module. " alt="xpcc::stm32::AdcInterrupt3" shape="rect" coords="0,168,160,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a13aa1e896b3c735d44232d26aaa2f007"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">Channel</a> : uint8_t { <br />
&#160;&#160;<b>Channel0</b>, 
<br />
&#160;&#160;<b>Channel1</b>, 
<br />
&#160;&#160;<b>Channel2</b>, 
<br />
&#160;&#160;<b>Channel3</b>, 
<br />
&#160;&#160;<b>Channel4</b>, 
<br />
&#160;&#160;<b>Channel5</b>, 
<br />
&#160;&#160;<b>Channel6</b>, 
<br />
&#160;&#160;<b>Channel7</b>, 
<br />
&#160;&#160;<b>Channel8</b>, 
<br />
&#160;&#160;<b>Channel9</b>, 
<br />
&#160;&#160;<b>Channel10</b>, 
<br />
&#160;&#160;<b>Channel11</b>, 
<br />
&#160;&#160;<b>Channel12</b>, 
<br />
&#160;&#160;<b>Channel13</b>, 
<br />
&#160;&#160;<b>Channel14</b>, 
<br />
&#160;&#160;<b>Channel15</b>, 
<br />
&#160;&#160;<b>Channel16</b>, 
<br />
&#160;&#160;<b>Channel17</b>, 
<br />
&#160;&#160;<b>Channel18</b>, 
<br />
&#160;&#160;<b>BatDiv2</b>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007a345b3ea3fe508e0716705a05b619c5b3">Channel::TemperatureSensor</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007aee534ac11d9a6aad6664a4a0ccd40648">Channel::InternalReference</a>
<br />
 }<tr class="memdesc:a13aa1e896b3c735d44232d26aaa2f007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channels, which can be used with this ADC.  <a href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">More...</a><br /></td></tr>
<tr class="separator:a13aa1e896b3c735d44232d26aaa2f007"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ae685a7f473e281c41cfd6e9252a52a19"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19a566b3c3160669652a57c5499de449d39">SampleTime::Cycles3</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19a2500aa43f1a32532aafdd1132c19fbae">SampleTime::Cycles15</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19af0f7dc86377e0ac3ac709419a817a57b">SampleTime::Cycles28</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19ab840153c6a922c709e6e0f2ce1397d7b">SampleTime::Cycles56</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19abfed02eab46aad846a310b075d4b5f15">SampleTime::Cycles84</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19a02071b68128c5337acb6ec1b3fcb1704">SampleTime::Cycles112</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19a9e612fe4954c9b4798fc6ecb4ecae6ca">SampleTime::Cycles144</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19aa12282069226b28e9669a5df67d05850">SampleTime::Cycles480</a>
<br />
 }<tr class="memdesc:ae685a7f473e281c41cfd6e9252a52a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling time of the input voltage.  <a href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">More...</a><br /></td></tr>
<tr class="separator:ae685a7f473e281c41cfd6e9252a52a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a0da1e9e0cdb9d370a9558b359b95a139"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a0da1e9e0cdb9d370a9558b359b95a139">Interrupt</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a0da1e9e0cdb9d370a9558b359b95a139a70402160707bec39bb8fe0cf68c79080">Interrupt::AnalogWatchdog</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a0da1e9e0cdb9d370a9558b359b95a139a7a965fe2d1303348db7923c5dd7fa47a">Interrupt::EndOfRegularConversion</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a0da1e9e0cdb9d370a9558b359b95a139ac02d932e9cb6790b6f7189f994a97c33">Interrupt::EndOfInjectedConversion</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a0da1e9e0cdb9d370a9558b359b95a139a9fa996dc830f67a458e46cf1463d5cd3">Interrupt::Overrun</a>
<br />
 }<tr class="memdesc:a0da1e9e0cdb9d370a9558b359b95a139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible interrupts.  <a href="classxpcc_1_1stm32_1_1_adc3.html#a0da1e9e0cdb9d370a9558b359b95a139">More...</a><br /></td></tr>
<tr class="separator:a0da1e9e0cdb9d370a9558b359b95a139"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:af05d3b8f687d0a96aef1ef62a8aa01a8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af05d3b8f687d0a96aef1ef62a8aa01a8">InterruptFlag</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af05d3b8f687d0a96aef1ef62a8aa01a8a70402160707bec39bb8fe0cf68c79080">InterruptFlag::AnalogWatchdog</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af05d3b8f687d0a96aef1ef62a8aa01a8a7a965fe2d1303348db7923c5dd7fa47a">InterruptFlag::EndOfRegularConversion</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af05d3b8f687d0a96aef1ef62a8aa01a8ac02d932e9cb6790b6f7189f994a97c33">InterruptFlag::EndOfInjectedConversion</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af05d3b8f687d0a96aef1ef62a8aa01a8a9fa996dc830f67a458e46cf1463d5cd3">InterruptFlag::Overrun</a>, 
<br />
&#160;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af05d3b8f687d0a96aef1ef62a8aa01a8ab1c94ca2fbc3e78fc30069c8d0f01680">InterruptFlag::All</a>
<br />
 }<tr class="separator:af05d3b8f687d0a96aef1ef62a8aa01a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a9dc8e4d800b0502a362b37b0f9090c7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dc8e4d800b0502a362b37b0f9090c7a"></a>
typedef <a class="el" href="group__register.html#ga878a50776c1c9e6d27bd82ad4c579efd">xpcc::Flags32</a>&lt; <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a0da1e9e0cdb9d370a9558b359b95a139">Interrupt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Interrupt_t</b></td></tr>
<tr class="separator:a9dc8e4d800b0502a362b37b0f9090c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0c7880793581ee1edf150e8babfa08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c0c7880793581ee1edf150e8babfa08"></a>
typedef <a class="el" href="group__register.html#ga878a50776c1c9e6d27bd82ad4c579efd">xpcc::Flags32</a>&lt; <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af05d3b8f687d0a96aef1ef62a8aa01a8">InterruptFlag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InterruptFlag_t</b></td></tr>
<tr class="separator:a7c0c7880793581ee1edf150e8babfa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxpcc_1_1_adc"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxpcc_1_1_adc')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxpcc_1_1_adc.html">xpcc::Adc</a></td></tr>
<tr class="memitem:ab4ad09b0e8dbf2d2f4ede2c985140798 inherit pub_types_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4ad09b0e8dbf2d2f4ede2c985140798"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#ab4ad09b0e8dbf2d2f4ede2c985140798">Channel</a></td></tr>
<tr class="memdesc:ab4ad09b0e8dbf2d2f4ede2c985140798 inherit pub_types_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">this type may also be an enum or enum class <br /></td></tr>
<tr class="separator:ab4ad09b0e8dbf2d2f4ede2c985140798 inherit pub_types_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2bc3cf44e0c73ce813d5ecc28990442b"><td class="memTemplParams" colspan="2">template&lt;class SystemClock , uint32_t frequency = 10000000, uint16_t tolerance = xpcc::Tolerance::TenPercent&gt; </td></tr>
<tr class="memitem:a2bc3cf44e0c73ce813d5ecc28990442b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a2bc3cf44e0c73ce813d5ecc28990442b">initialize</a> ()</td></tr>
<tr class="memdesc:a2bc3cf44e0c73ce813d5ecc28990442b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and enable the A/D converter.  <a href="#a2bc3cf44e0c73ce813d5ecc28990442b">More...</a><br /></td></tr>
<tr class="separator:a2bc3cf44e0c73ce813d5ecc28990442b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec716265adb3049cfdf1ca919d0933a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ec716265adb3049cfdf1ca919d0933a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>disable</b> ()</td></tr>
<tr class="separator:a2ec716265adb3049cfdf1ca919d0933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54861e2bdb0b36a5540a628dbc579a54"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a54861e2bdb0b36a5540a628dbc579a54">startConversion</a> ()</td></tr>
<tr class="memdesc:a54861e2bdb0b36a5540a628dbc579a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new conversion or continuous conversions.  <a href="#a54861e2bdb0b36a5540a628dbc579a54">More...</a><br /></td></tr>
<tr class="separator:a54861e2bdb0b36a5540a628dbc579a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e484f6b5bcbe7a501db5071b52fc59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8e484f6b5bcbe7a501db5071b52fc59"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isConversionFinished</b> ()</td></tr>
<tr class="separator:ac8e484f6b5bcbe7a501db5071b52fc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f35b46e06dbc16506ceea57d2e83a29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f35b46e06dbc16506ceea57d2e83a29"></a>
static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>getValue</b> ()</td></tr>
<tr class="separator:a8f35b46e06dbc16506ceea57d2e83a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dd6dcb2dc33915911d5f6ccf25d615"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7dd6dcb2dc33915911d5f6ccf25d615"></a>
static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>readChannel</b> (<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">Channel</a> channel)</td></tr>
<tr class="separator:ac7dd6dcb2dc33915911d5f6ccf25d615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b338bf8cb443df8d32c7b62db19cc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ac54b338bf8cb443df8d32c7b62db19cc">setChannel</a> (const <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">Channel</a> channel, const <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a> sampleTime=static_cast&lt; <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a> &gt;(0b000))</td></tr>
<tr class="memdesc:ac54b338bf8cb443df8d32c7b62db19cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog channel selection.  <a href="#ac54b338bf8cb443df8d32c7b62db19cc">More...</a><br /></td></tr>
<tr class="separator:ac54b338bf8cb443df8d32c7b62db19cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9873d834757843d3ecfe368f0f91ab32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9873d834757843d3ecfe368f0f91ab32"></a>
static <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">Channel</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getChannel</b> ()</td></tr>
<tr class="separator:a9873d834757843d3ecfe368f0f91ab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0090d6367ac532d4253530ddd09b73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e0090d6367ac532d4253530ddd09b73"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>enableFreeRunningMode</b> ()</td></tr>
<tr class="separator:a7e0090d6367ac532d4253530ddd09b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c21660d41b8f7ca4ac531f072f7b9bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c21660d41b8f7ca4ac531f072f7b9bf"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>disableFreeRunningMode</b> ()</td></tr>
<tr class="separator:a7c21660d41b8f7ca4ac531f072f7b9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab987ded42140d7b652d27860d3a5c9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab987ded42140d7b652d27860d3a5c9b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setLeftAdjustResult</b> ()</td></tr>
<tr class="separator:aab987ded42140d7b652d27860d3a5c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04c8adafc887f9a70e41d4792047cc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad04c8adafc887f9a70e41d4792047cc7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setRightAdjustResult</b> ()</td></tr>
<tr class="separator:ad04c8adafc887f9a70e41d4792047cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa629ac18afc0713f67f5cdadffa1ee29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa629ac18afc0713f67f5cdadffa1ee29"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#aa629ac18afc0713f67f5cdadffa1ee29">enableTemperatureRefVMeasurement</a> ()</td></tr>
<tr class="memdesc:aa629ac18afc0713f67f5cdadffa1ee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch on temperature- and V_REF measurement. <br /></td></tr>
<tr class="separator:aa629ac18afc0713f67f5cdadffa1ee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc11c443bb4d2339e92786fbefef0217"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc11c443bb4d2339e92786fbefef0217"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#abc11c443bb4d2339e92786fbefef0217">disableTemperatureRefVMeasurement</a> ()</td></tr>
<tr class="memdesc:abc11c443bb4d2339e92786fbefef0217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch on temperature- and V_REF measurement. <br /></td></tr>
<tr class="separator:abc11c443bb4d2339e92786fbefef0217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd53ac4674339a9360b7f49043f47cde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd53ac4674339a9360b7f49043f47cde"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#acd53ac4674339a9360b7f49043f47cde">addChannel</a> (const <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">Channel</a> channel, const <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a> sampleTime=static_cast&lt; <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a> &gt;(0b000))</td></tr>
<tr class="memdesc:acd53ac4674339a9360b7f49043f47cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a channel to conversion group. <br /></td></tr>
<tr class="separator:acd53ac4674339a9360b7f49043f47cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f42b064d93fb9df724c4f43656d310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55f42b064d93fb9df724c4f43656d310"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a55f42b064d93fb9df724c4f43656d310">setSampleTime</a> (const <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">Channel</a> channel, const <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a> sampleTime=static_cast&lt; <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a> &gt;(0b000))</td></tr>
<tr class="memdesc:a55f42b064d93fb9df724c4f43656d310"><td class="mdescLeft">&#160;</td><td class="mdescRight">change sample time of ADC channel <br /></td></tr>
<tr class="separator:a55f42b064d93fb9df724c4f43656d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f95e1ae941e96d79ca97d6805ff87e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f95e1ae941e96d79ca97d6805ff87e9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>enableInterruptVector</b> (const uint32_t priority, const bool enable=true)</td></tr>
<tr class="separator:a3f95e1ae941e96d79ca97d6805ff87e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6846ee63e5fdde6d5feab2f2863312df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a6846ee63e5fdde6d5feab2f2863312df">enableInterrupt</a> (const <a class="el" href="structxpcc_1_1_flags.html">Interrupt_t</a> interrupt)</td></tr>
<tr class="memdesc:a6846ee63e5fdde6d5feab2f2863312df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the ADC Conversion Complete Interrupt.  <a href="#a6846ee63e5fdde6d5feab2f2863312df">More...</a><br /></td></tr>
<tr class="separator:a6846ee63e5fdde6d5feab2f2863312df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69855f5f704de62e1f08f42e754f9fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad69855f5f704de62e1f08f42e754f9fb"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ad69855f5f704de62e1f08f42e754f9fb">disableInterrupt</a> (const <a class="el" href="structxpcc_1_1_flags.html">Interrupt_t</a> interrupt)</td></tr>
<tr class="memdesc:ad69855f5f704de62e1f08f42e754f9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the ADC Conversion Complete Interrupt. <br /></td></tr>
<tr class="separator:ad69855f5f704de62e1f08f42e754f9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61d0241619cc3c76091e67dcb418c25"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structxpcc_1_1_flags.html">InterruptFlag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ad61d0241619cc3c76091e67dcb418c25">getInterruptFlags</a> ()</td></tr>
<tr class="memdesc:ad61d0241619cc3c76091e67dcb418c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the th interrupt flags set.  <a href="#ad61d0241619cc3c76091e67dcb418c25">More...</a><br /></td></tr>
<tr class="separator:ad61d0241619cc3c76091e67dcb418c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f8d57982449317715e8b5bf58545a1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a68f8d57982449317715e8b5bf58545a1">acknowledgeInterruptFlags</a> (const <a class="el" href="structxpcc_1_1_flags.html">InterruptFlag_t</a> flags)</td></tr>
<tr class="memdesc:a68f8d57982449317715e8b5bf58545a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified interrupt flag.  <a href="#a68f8d57982449317715e8b5bf58545a1">More...</a><br /></td></tr>
<tr class="separator:a68f8d57982449317715e8b5bf58545a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxpcc_1_1_adc"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxpcc_1_1_adc')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxpcc_1_1_adc.html">xpcc::Adc</a></td></tr>
<tr class="memitem:ae1d731d0e43be5058f5771cbfd6894c7 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memTemplParams" colspan="2">template&lt;class SystemClock , uint32_t frequency = 200000, uint16_t tolerance = Tolerance::TenPercent&gt; </td></tr>
<tr class="memitem:ae1d731d0e43be5058f5771cbfd6894c7 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#ae1d731d0e43be5058f5771cbfd6894c7">initialize</a> ()</td></tr>
<tr class="memdesc:ae1d731d0e43be5058f5771cbfd6894c7 inherit pub_static_methods_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the hardware and sets the datarate.  <a href="#ae1d731d0e43be5058f5771cbfd6894c7">More...</a><br /></td></tr>
<tr class="separator:ae1d731d0e43be5058f5771cbfd6894c7 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4f67bfb7a1ec6f10a8cde9ee229e5b inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac4f67bfb7a1ec6f10a8cde9ee229e5b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>disable</b> ()</td></tr>
<tr class="separator:aac4f67bfb7a1ec6f10a8cde9ee229e5b inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8422a301f21d7a5b9b8d6ea3b9f60 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#a49c8422a301f21d7a5b9b8d6ea3b9f60">startConversion</a> ()</td></tr>
<tr class="memdesc:a49c8422a301f21d7a5b9b8d6ea3b9f60 inherit pub_static_methods_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">starts a conversion on the selected analog channel  <a href="#a49c8422a301f21d7a5b9b8d6ea3b9f60">More...</a><br /></td></tr>
<tr class="separator:a49c8422a301f21d7a5b9b8d6ea3b9f60 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8ad070bfecf7412124f7f001f418eb inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#a5e8ad070bfecf7412124f7f001f418eb">isConversionFinished</a> ()</td></tr>
<tr class="separator:a5e8ad070bfecf7412124f7f001f418eb inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3477db1f2eaf77d10754277acbce0245 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#a3477db1f2eaf77d10754277acbce0245">getValue</a> ()</td></tr>
<tr class="separator:a3477db1f2eaf77d10754277acbce0245 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfc8a6eecc1f0c2b9dc78873c811076 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#a1dfc8a6eecc1f0c2b9dc78873c811076">readChannel</a> (<a class="el" href="classxpcc_1_1_adc.html#ab4ad09b0e8dbf2d2f4ede2c985140798">Channel</a> channel)</td></tr>
<tr class="memdesc:a1dfc8a6eecc1f0c2b9dc78873c811076 inherit pub_static_methods_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function:  <a href="#a1dfc8a6eecc1f0c2b9dc78873c811076">More...</a><br /></td></tr>
<tr class="separator:a1dfc8a6eecc1f0c2b9dc78873c811076 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767478a3f66ec7baab40fceb631dae09 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#a767478a3f66ec7baab40fceb631dae09">setChannel</a> (<a class="el" href="classxpcc_1_1_adc.html#ab4ad09b0e8dbf2d2f4ede2c985140798">Channel</a> channel)</td></tr>
<tr class="memdesc:a767478a3f66ec7baab40fceb631dae09 inherit pub_static_methods_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog channel selection.  <a href="#a767478a3f66ec7baab40fceb631dae09">More...</a><br /></td></tr>
<tr class="separator:a767478a3f66ec7baab40fceb631dae09 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bc6544d05b6c02c89bb0265446fa8b inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#ac3bc6544d05b6c02c89bb0265446fa8b">getChannel</a> ()</td></tr>
<tr class="separator:ac3bc6544d05b6c02c89bb0265446fa8b inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb02f5a03d125050b22e7acd24f92dc inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#acdb02f5a03d125050b22e7acd24f92dc">enableFreeRunningMode</a> ()</td></tr>
<tr class="memdesc:acdb02f5a03d125050b22e7acd24f92dc inherit pub_static_methods_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables free running mode.  <a href="#acdb02f5a03d125050b22e7acd24f92dc">More...</a><br /></td></tr>
<tr class="separator:acdb02f5a03d125050b22e7acd24f92dc inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca7efb41601408b69bec0a36f487366 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#a8ca7efb41601408b69bec0a36f487366">disableFreeRunningMode</a> ()</td></tr>
<tr class="memdesc:a8ca7efb41601408b69bec0a36f487366 inherit pub_static_methods_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables free running mode.  <a href="#a8ca7efb41601408b69bec0a36f487366">More...</a><br /></td></tr>
<tr class="separator:a8ca7efb41601408b69bec0a36f487366 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74cc1dc7af2f74318dd89300ff474e4 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac74cc1dc7af2f74318dd89300ff474e4"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#ac74cc1dc7af2f74318dd89300ff474e4">setLeftAdjustResult</a> ()</td></tr>
<tr class="memdesc:ac74cc1dc7af2f74318dd89300ff474e4 inherit pub_static_methods_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the presentation of the ADC conversion result to left adjusted. <br /></td></tr>
<tr class="separator:ac74cc1dc7af2f74318dd89300ff474e4 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c582bbfb00d90ac7b0f24b6d0c49c94 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c582bbfb00d90ac7b0f24b6d0c49c94"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#a0c582bbfb00d90ac7b0f24b6d0c49c94">setRightAdjustResult</a> ()</td></tr>
<tr class="memdesc:a0c582bbfb00d90ac7b0f24b6d0c49c94 inherit pub_static_methods_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the presentation of the ADC conversion result to right adjusted. <br /></td></tr>
<tr class="separator:a0c582bbfb00d90ac7b0f24b6d0c49c94 inherit pub_static_methods_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classxpcc_1_1_peripheral"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxpcc_1_1_peripheral')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxpcc_1_1_peripheral.html">xpcc::Peripheral</a></td></tr>
<tr class="memitem:a6333658727bd8ed30333f0b0e3165d56 inherit pub_static_methods_classxpcc_1_1_peripheral"><td class="memTemplParams" colspan="2">template&lt;uint32_t available, uint32_t requested, uint16_t tolerance&gt; </td></tr>
<tr class="memitem:a6333658727bd8ed30333f0b0e3165d56 inherit pub_static_methods_classxpcc_1_1_peripheral"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_peripheral.html#a6333658727bd8ed30333f0b0e3165d56">assertBaudrateInTolerance</a> ()</td></tr>
<tr class="memdesc:a6333658727bd8ed30333f0b0e3165d56 inherit pub_static_methods_classxpcc_1_1_peripheral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since baudrates are usually generated by prescaling a system clock, only several distinct values can be generated.  <a href="#a6333658727bd8ed30333f0b0e3165d56">More...</a><br /></td></tr>
<tr class="separator:a6333658727bd8ed30333f0b0e3165d56 inherit pub_static_methods_classxpcc_1_1_peripheral"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad2a6525a681495d53de41203e1b225a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a6525a681495d53de41203e1b225a0"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel0.html">TypeId::Adc3Channel0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ad2a6525a681495d53de41203e1b225a0">Channel0</a></td></tr>
<tr class="memdesc:ad2a6525a681495d53de41203e1b225a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel0. <br /></td></tr>
<tr class="separator:ad2a6525a681495d53de41203e1b225a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d74c375f24d7f2f3d42fbf0540598b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d74c375f24d7f2f3d42fbf0540598b8"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel1.html">TypeId::Adc3Channel1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a4d74c375f24d7f2f3d42fbf0540598b8">Channel1</a></td></tr>
<tr class="memdesc:a4d74c375f24d7f2f3d42fbf0540598b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel1. <br /></td></tr>
<tr class="separator:a4d74c375f24d7f2f3d42fbf0540598b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fff2691188fe1a9594844ba7720e2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4fff2691188fe1a9594844ba7720e2c"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel2.html">TypeId::Adc3Channel2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ab4fff2691188fe1a9594844ba7720e2c">Channel2</a></td></tr>
<tr class="memdesc:ab4fff2691188fe1a9594844ba7720e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel2. <br /></td></tr>
<tr class="separator:ab4fff2691188fe1a9594844ba7720e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7a8e8cf75d93e2d8bcbd13cc9750d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad7a8e8cf75d93e2d8bcbd13cc9750d2"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel3.html">TypeId::Adc3Channel3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#aad7a8e8cf75d93e2d8bcbd13cc9750d2">Channel3</a></td></tr>
<tr class="memdesc:aad7a8e8cf75d93e2d8bcbd13cc9750d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel3. <br /></td></tr>
<tr class="separator:aad7a8e8cf75d93e2d8bcbd13cc9750d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1cd770d5afc8979fe5b3e7346a4916"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c1cd770d5afc8979fe5b3e7346a4916"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel4.html">TypeId::Adc3Channel4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a2c1cd770d5afc8979fe5b3e7346a4916">Channel4</a></td></tr>
<tr class="memdesc:a2c1cd770d5afc8979fe5b3e7346a4916"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel4. <br /></td></tr>
<tr class="separator:a2c1cd770d5afc8979fe5b3e7346a4916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432458a085f26259537981dd188a2a30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a432458a085f26259537981dd188a2a30"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel5.html">TypeId::Adc3Channel5</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a432458a085f26259537981dd188a2a30">Channel5</a></td></tr>
<tr class="memdesc:a432458a085f26259537981dd188a2a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel5. <br /></td></tr>
<tr class="separator:a432458a085f26259537981dd188a2a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f82a5460486bcacfc86a1d2ff2248d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3f82a5460486bcacfc86a1d2ff2248d"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel6.html">TypeId::Adc3Channel6</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af3f82a5460486bcacfc86a1d2ff2248d">Channel6</a></td></tr>
<tr class="memdesc:af3f82a5460486bcacfc86a1d2ff2248d"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel6. <br /></td></tr>
<tr class="separator:af3f82a5460486bcacfc86a1d2ff2248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c110638b88aab888b9bd23dbf6a706"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9c110638b88aab888b9bd23dbf6a706"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel7.html">TypeId::Adc3Channel7</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ab9c110638b88aab888b9bd23dbf6a706">Channel7</a></td></tr>
<tr class="memdesc:ab9c110638b88aab888b9bd23dbf6a706"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel7. <br /></td></tr>
<tr class="separator:ab9c110638b88aab888b9bd23dbf6a706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93790e9786523b8f5c2900b9008bedd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad93790e9786523b8f5c2900b9008bedd"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel8.html">TypeId::Adc3Channel8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ad93790e9786523b8f5c2900b9008bedd">Channel8</a></td></tr>
<tr class="memdesc:ad93790e9786523b8f5c2900b9008bedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel8. <br /></td></tr>
<tr class="separator:ad93790e9786523b8f5c2900b9008bedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153b2211fd66f580e80cb17d3bf210d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a153b2211fd66f580e80cb17d3bf210d1"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel9.html">TypeId::Adc3Channel9</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a153b2211fd66f580e80cb17d3bf210d1">Channel9</a></td></tr>
<tr class="memdesc:a153b2211fd66f580e80cb17d3bf210d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel9. <br /></td></tr>
<tr class="separator:a153b2211fd66f580e80cb17d3bf210d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5039be09e2387f996508714e2a88ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e5039be09e2387f996508714e2a88ec"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel10.html">TypeId::Adc3Channel10</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a0e5039be09e2387f996508714e2a88ec">Channel10</a></td></tr>
<tr class="memdesc:a0e5039be09e2387f996508714e2a88ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel10. <br /></td></tr>
<tr class="separator:a0e5039be09e2387f996508714e2a88ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae770be01ac10542145fda26ba8d5e1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae770be01ac10542145fda26ba8d5e1e"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel11.html">TypeId::Adc3Channel11</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#aae770be01ac10542145fda26ba8d5e1e">Channel11</a></td></tr>
<tr class="memdesc:aae770be01ac10542145fda26ba8d5e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel11. <br /></td></tr>
<tr class="separator:aae770be01ac10542145fda26ba8d5e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10400f30bec78f29e1cb31cc39ba5254"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10400f30bec78f29e1cb31cc39ba5254"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel12.html">TypeId::Adc3Channel12</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a10400f30bec78f29e1cb31cc39ba5254">Channel12</a></td></tr>
<tr class="memdesc:a10400f30bec78f29e1cb31cc39ba5254"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel12. <br /></td></tr>
<tr class="separator:a10400f30bec78f29e1cb31cc39ba5254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c002d6fb82859c541d34c3460ec57ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c002d6fb82859c541d34c3460ec57ef"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel13.html">TypeId::Adc3Channel13</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a9c002d6fb82859c541d34c3460ec57ef">Channel13</a></td></tr>
<tr class="memdesc:a9c002d6fb82859c541d34c3460ec57ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel13. <br /></td></tr>
<tr class="separator:a9c002d6fb82859c541d34c3460ec57ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96201c5b40508f60352e2430a171efe0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96201c5b40508f60352e2430a171efe0"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel14.html">TypeId::Adc3Channel14</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a96201c5b40508f60352e2430a171efe0">Channel14</a></td></tr>
<tr class="memdesc:a96201c5b40508f60352e2430a171efe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel14. <br /></td></tr>
<tr class="separator:a96201c5b40508f60352e2430a171efe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636870e04f7710252d266632aaac4108"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a636870e04f7710252d266632aaac4108"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel15.html">TypeId::Adc3Channel15</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a636870e04f7710252d266632aaac4108">Channel15</a></td></tr>
<tr class="memdesc:a636870e04f7710252d266632aaac4108"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel15. <br /></td></tr>
<tr class="separator:a636870e04f7710252d266632aaac4108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9e9612567c0121773ddd215ad47349"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf9e9612567c0121773ddd215ad47349"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel16.html">TypeId::Adc3Channel16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#aaf9e9612567c0121773ddd215ad47349">Channel16</a></td></tr>
<tr class="memdesc:aaf9e9612567c0121773ddd215ad47349"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel16. <br /></td></tr>
<tr class="separator:aaf9e9612567c0121773ddd215ad47349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29dcd23a661b07e40f1db28aa3a26a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa29dcd23a661b07e40f1db28aa3a26a7"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel17.html">TypeId::Adc3Channel17</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#aa29dcd23a661b07e40f1db28aa3a26a7">Channel17</a></td></tr>
<tr class="memdesc:aa29dcd23a661b07e40f1db28aa3a26a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel17. <br /></td></tr>
<tr class="separator:aa29dcd23a661b07e40f1db28aa3a26a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae110cc32bde5c980b98f192f690aabce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae110cc32bde5c980b98f192f690aabce"></a>
static const <a class="el" href="structxpcc_1_1stm32_1_1_type_id_1_1_adc3_channel18.html">TypeId::Adc3Channel18</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae110cc32bde5c980b98f192f690aabce">Channel18</a></td></tr>
<tr class="memdesc:ae110cc32bde5c980b98f192f690aabce"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeId used to connect GPIO pins to this adc's Channel18. <br /></td></tr>
<tr class="separator:ae110cc32bde5c980b98f192f690aabce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a8f37fec291ef55ad81665c4453a9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05a8f37fec291ef55ad81665c4453a9c"></a>
static constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>Resolution</b></td></tr>
<tr class="separator:a05a8f37fec291ef55ad81665c4453a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classxpcc_1_1_adc"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classxpcc_1_1_adc')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classxpcc_1_1_adc.html">xpcc::Adc</a></td></tr>
<tr class="memitem:ab6d2a211be55474117a89e2f846f097c inherit pub_static_attribs_classxpcc_1_1_adc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d2a211be55474117a89e2f846f097c"></a>
static constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxpcc_1_1_adc.html#ab6d2a211be55474117a89e2f846f097c">Resolution</a></td></tr>
<tr class="memdesc:ab6d2a211be55474117a89e2f846f097c inherit pub_static_attribs_classxpcc_1_1_adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">describes the maximum resolution in bits <br /></td></tr>
<tr class="separator:ab6d2a211be55474117a89e2f846f097c inherit pub_static_attribs_classxpcc_1_1_adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The 12-bit ADC is a successive approximation analog-to-digital converter. It has up to 18 multiplexed channels allowing it to measure signals from 16 external and two internal sources. The result of the ADC is stored in a left-aligned or right-aligned 16-bit data register.</p>
<dl class="section author"><dt>Author</dt><dd>Stephan Kugelmann </dd>
<dd>
David Hebbeker </dd>
<dd>
ekiwi </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a13aa1e896b3c735d44232d26aaa2f007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">xpcc::stm32::Adc3::Channel</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You can specify the channel by using a pin-name, like PIN_C0, an internal sensor, like TEMPERATURE_SENSOR or just the plain channel number, like CHANNEL_0. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a13aa1e896b3c735d44232d26aaa2f007a345b3ea3fe508e0716705a05b619c5b3"></a>TemperatureSensor&#160;</td><td class="fielddoc">
<p>Half the V_BAT voltage. </p>
<p>Measure the ambient temperature of the device. </p><pre class="fragment">   @li Supported temperature range: -40 to 125 C
   @li Precision: +-1.5 C

   @see Reference manual (i.e. RM0090) for the formula for the
    calculation of the actual temperature.
   @note The TSVREFE bit must be set to enable the conversion of
    this internal channel.</pre> </td></tr>
<tr><td class="fieldname"><a class="anchor" id="a13aa1e896b3c735d44232d26aaa2f007aee534ac11d9a6aad6664a4a0ccd40648"></a>InternalReference&#160;</td><td class="fielddoc">
<p>Internal reference voltage. </p>
<dl class="section note"><dt>Note</dt><dd>The TSVREFE bit must be set to enable the conversion of this internal channel. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">xpcc::stm32::Adc3::SampleTime</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total conversion time is T_con = Sampling time + 12 cycles </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19a566b3c3160669652a57c5499de449d39"></a>Cycles3&#160;</td><td class="fielddoc">
<p>3 ADCCLK cycles </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19a2500aa43f1a32532aafdd1132c19fbae"></a>Cycles15&#160;</td><td class="fielddoc">
<p>15 ADCCLK cycles </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19af0f7dc86377e0ac3ac709419a817a57b"></a>Cycles28&#160;</td><td class="fielddoc">
<p>28 ADCCLK cycles </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19ab840153c6a922c709e6e0f2ce1397d7b"></a>Cycles56&#160;</td><td class="fielddoc">
<p>56 ADCCLK cycles </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19abfed02eab46aad846a310b075d4b5f15"></a>Cycles84&#160;</td><td class="fielddoc">
<p>84 ADCCLK cycles </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19a02071b68128c5337acb6ec1b3fcb1704"></a>Cycles112&#160;</td><td class="fielddoc">
<p>112 ADCCLK cycles </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19a9e612fe4954c9b4798fc6ecb4ecae6ca"></a>Cycles144&#160;</td><td class="fielddoc">
<p>144 ADCCLK cycles </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae685a7f473e281c41cfd6e9252a52a19aa12282069226b28e9669a5df67d05850"></a>Cycles480&#160;</td><td class="fielddoc">
<p>480 ADCCLK cycles </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a0da1e9e0cdb9d370a9558b359b95a139"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a0da1e9e0cdb9d370a9558b359b95a139">xpcc::stm32::Adc3::Interrupt</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An interrupt can be produced on the end of conversion for regular and injected groups, when the analog watchdog status bit is set and when the overrun status bit is set. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0da1e9e0cdb9d370a9558b359b95a139a70402160707bec39bb8fe0cf68c79080"></a>AnalogWatchdog&#160;</td><td class="fielddoc">
<p>Analog watchdog status bit is set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0da1e9e0cdb9d370a9558b359b95a139a7a965fe2d1303348db7923c5dd7fa47a"></a>EndOfRegularConversion&#160;</td><td class="fielddoc">
<p>End of conversion of a regular group. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0da1e9e0cdb9d370a9558b359b95a139ac02d932e9cb6790b6f7189f994a97c33"></a>EndOfInjectedConversion&#160;</td><td class="fielddoc">
<p>End of conversion of an injected group. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0da1e9e0cdb9d370a9558b359b95a139a9fa996dc830f67a458e46cf1463d5cd3"></a>Overrun&#160;</td><td class="fielddoc">
<p>Overrun (if data are lost) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af05d3b8f687d0a96aef1ef62a8aa01a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#af05d3b8f687d0a96aef1ef62a8aa01a8">xpcc::stm32::Adc3::InterruptFlag</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af05d3b8f687d0a96aef1ef62a8aa01a8a70402160707bec39bb8fe0cf68c79080"></a>AnalogWatchdog&#160;</td><td class="fielddoc">
<p>Analog watchdog status bit is set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af05d3b8f687d0a96aef1ef62a8aa01a8a7a965fe2d1303348db7923c5dd7fa47a"></a>EndOfRegularConversion&#160;</td><td class="fielddoc">
<p>End of conversion of a regular group. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af05d3b8f687d0a96aef1ef62a8aa01a8ac02d932e9cb6790b6f7189f994a97c33"></a>EndOfInjectedConversion&#160;</td><td class="fielddoc">
<p>End of conversion of an injected group. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af05d3b8f687d0a96aef1ef62a8aa01a8a9fa996dc830f67a458e46cf1463d5cd3"></a>Overrun&#160;</td><td class="fielddoc">
<p>Overrun (if data are lost) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af05d3b8f687d0a96aef1ef62a8aa01a8ab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc">
<p>All InterruptFlags. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2bc3cf44e0c73ce813d5ecc28990442b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemClock , uint32_t frequency = 10000000, uint16_t tolerance = xpcc::Tolerance::TenPercent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xpcc::stm32::Adc3::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enables the ADC clock and switches on the ADC. The ADC clock prescaler will be set as well.</p>
<p>The ADC clock must not exceed 36 MHz for Vdd &gt; 2.4V, or 18MHz for Vdd &lt; 2.4V. </p>

</div>
</div>
<a class="anchor" id="a54861e2bdb0b36a5540a628dbc579a54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xpcc::stm32::Adc3::startConversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section pre"><dt>Precondition</dt><dd>A ADC channel must be selected with <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ac54b338bf8cb443df8d32c7b62db19cc" title="Analog channel selection. ">setChannel()</a>. When using a STM32F10x a delay of at least t_STAB after <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a2bc3cf44e0c73ce813d5ecc28990442b" title="Initialize and enable the A/D converter. ">initialize()</a> must be waited!</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The result can be fetched with getValue() </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>When using a STM32F10x, the application should allow a delay of t_STAB between power up and start of conversion. Refer to Reference Manual (RM0008) ADC_CR2_ADON. </dd></dl>

</div>
</div>
<a class="anchor" id="ac54b338bf8cb443df8d32c7b62db19cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool xpcc::stm32::Adc3::setChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a13aa1e896b3c735d44232d26aaa2f007">Channel</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a>&#160;</td>
          <td class="paramname"><em>sampleTime</em> = <code>static_cast&lt;&#160;<a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#ae685a7f473e281c41cfd6e9252a52a19">SampleTime</a>&#160;&gt;(0b000)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This not for scan mode. The number of channels will be set to 1, the channel selected and the corresponding pin will be set to analog input. If the the channel is modified during a conversion, the current conversion is reset and a new start pulse is sent to the ADC to convert the new chosen channnel / group of channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel which shall be read. </td></tr>
    <tr><td class="paramname">sampleTime</td><td>The sample time to sample the input voltage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ADC clock must be started and the ADC switched on with <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a2bc3cf44e0c73ce813d5ecc28990442b" title="Initialize and enable the A/D converter. ">initialize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6846ee63e5fdde6d5feab2f2863312df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xpcc::stm32::Adc3::enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxpcc_1_1_flags.html">Interrupt_t</a>&#160;</td>
          <td class="paramname"><em>interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You could catch the interrupt using this example function: </p><ul>
<li>for STM32F4XX: <code><a class="el" href="group__platform.html#ga8c519bcbffa546525acc426192db9f73" title="Declare an interrupt handler. ">XPCC_ISR(ADC)</a></code> </li>
<li>for STM32F10X: <code><a class="el" href="group__platform.html#ga8c519bcbffa546525acc426192db9f73" title="Declare an interrupt handler. ">XPCC_ISR(ADC1_2)</a></code></li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The ADC clock must be started and the ADC switched on with <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a2bc3cf44e0c73ce813d5ecc28990442b" title="Initialize and enable the A/D converter. ">initialize()</a>. Also the Interrupt <a class="el" href="classxpcc_1_1_vector.html" title="Class for handling common point operations. ">Vector</a> needs to be enabled first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>Priority to set </td></tr>
    <tr><td class="paramname">interrupt</td><td>The interrupt, which shall be enabled. See Interrupt for available interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ADC1 and ADC2 interrupts are mapped onto the same interrupt vector. ADC3 interrupts are mapped onto a separate interrupt vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ad61d0241619cc3c76091e67dcb418c25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structxpcc_1_1_flags.html">InterruptFlag_t</a> xpcc::stm32::Adc3::getInterruptFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section pre"><dt>Precondition</dt><dd>The ADC clock must be started and the ADC switched on with <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a2bc3cf44e0c73ce813d5ecc28990442b" title="Initialize and enable the A/D converter. ">initialize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a68f8d57982449317715e8b5bf58545a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xpcc::stm32::Adc3::acknowledgeInterruptFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxpcc_1_1_flags.html">InterruptFlag_t</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>The interrupt flag, which shall be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The ADC clock must be started and the ADC switched on with <a class="el" href="classxpcc_1_1stm32_1_1_adc3.html#a2bc3cf44e0c73ce813d5ecc28990442b" title="Initialize and enable the A/D converter. ">initialize()</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>adc_3.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacexpcc.html">xpcc</a></li><li class="navelem"><b>stm32</b></li><li class="navelem"><a class="el" href="classxpcc_1_1stm32_1_1_adc3.html">Adc3</a></li>
    <li class="footer">Generated on Fri May 5 2017 22:29:39 for xpcc by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
