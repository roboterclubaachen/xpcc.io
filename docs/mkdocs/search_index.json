{
    "docs": [
        {
            "location": "/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nxpcc: C++ microcontroller framework \n#\n\n\nThe xpcc framework consists of powerful hardware abstraction layers for many\ndifferent microcontrollers, a set of drivers for various external targets and a general purpose toolbox for building hardware orientated applications.\n\n\nThe main goal of xpcc is to provide a usable API for barebone microcontroller programming,\nwhich is efficient enough to be deployed on a small ATtiny, yet powerful enough to make\nuse of advanced capabilities found on the 32bit ARM Cortex-M.\n\n\nxpcc is \nbattle-tested\n in the real-world, highly competitive\nenvironment of \nEurobot\n.\nIt is the foundation of all of \n@RCA_eV\n's robot code, and is the\nculmination of many years worth of effort, experience and improvements.\n\n\n\n\nFeast your eyes on lots of working examples\n.\n\n\nAPI reference is available here\n.\n\n\nWe have continuous integration as well\n.\n\n\nAnd we care a lot about testing\n.\n\n\n\n\nThis project also has \nguide for developers\n as well as a \ntechnical blog\n to document larger design concepts.\n\n\n\n\nYou have questions? \nAsk them on our mailing list\n\nor \nhave a look at the archive\n.\n\n\nYou found a bug? \nOpen up an issue, we don't bite\n.\n\n\nYou want to contribute? \nRead the contribution guidelines\n and \nopen a pull request so we can merge it\n.\n\n\nYou want to port xpcc? \nRead our porting guide\n.\n\n\n\n\nThe source code is freely available under a 3-clause BSD license, so feel\nfree to fork this project and adapt it to your needs.\nThe only thing we ask of you is to contribute your changes back.\nThat way everyone can profit.\n\n\nFeatures\n#\n\n\n\n\nEfficient and fast object-oriented C++11 API.\n\n\nSupport of AVR and ARM Cortex-M based microcontrollers from Atmel, ST and NXP.\n\n\nBuild system based on SCons and extendable using Python.\n\n\nData-driven HAL generation using Jinja2 template engine.\n\n\nNo memory allocations in HAL with very low overall RAM consumption.\n\n\nCross platform peripheral interfaces incl. bit banging:\n\n\nGPIO \n GPIO expanders\n\n\nADC\n\n\nUART, I2C, SPI\n\n\nCAN\n\n\n\n\n\n\nInterfaces for external I2C and SPI device drivers.\n\n\nDebug/logging system with IOStream interface.\n\n\nLightweight, stackless threads and resumable functions using cooperative multitasking.\n\n\nUseful mathematical and geometric algorithms optimized for microcontrollers.\n\n\nLightweight unit testing system (suitable for AVRs).\n\n\nGraphical user interface for small binary displays.\n\n\n\n\nSupported hardware\n#\n\n\nHere is a list of supported \nand tested\n microcontrollers and development boards:\n\n\n\n\n\n\n\n\nController\n\n\nDevelopment Board\n\n\nSupport\n\n\n\n\n\n\n\n\n\n\nAT90can\n\n\ncustom\n\n\n\n\n\n\n\n\nATtiny44a\n\n\ncustom\n\n\n\n\n\n\n\n\nATtiny85\n\n\ncustom\n\n\n\n\n\n\n\n\nATmega328p\n\n\nArduino Uno\n\n\n\n\n\n\n\n\nSTM32F072\n\n\nSTM32F072 Discovery\n\n\n\n\n\n\n\n\nSTM32F100\n\n\nSTM32F1 Discovery\n\n\n\n\n\n\n\n\nSTM32F103\n\n\nNucleo F103RB\n\n\n\n\n\n\n\n\nSTM32F103\n\n\nSTM32F1 Blue Pill\n\n\n\n\n\n\n\n\nSTM32F303\n\n\nSTM32F3 Discovery\n\n\n\n\n\n\n\n\nSTM32F303\n\n\nNucleo F303K8\n\n\n\n\n\n\n\n\nSTM32F407\n\n\nSTM32F4 Discovery\n\n\n\n\n\n\n\n\nSTM32F411\n\n\nNucleo F411RE\n\n\n\n\n\n\n\n\nSTM32F429\n\n\nSTM32F429 Discovery\n\n\n\n\n\n\n\n\nSTM32F429\n\n\nNucleo F429ZI\n\n\n\n\n\n\n\n\nSTM32F469\n\n\nSTM32F469 Discovery\n\n\n\n\n\n\n\n\nSTM32F746\n\n\nSTM32F746 Discovery\n\n\n\n\n\n\n\n\nSTM32F769\n\n\nSTM32F769 Discovery\n\n\n\n\n\n\n\n\nLPC11C24\n\n\nLPCxpresso\n\n\n\n\n\n\n\n\n\n\nAll of these targets are compiling and booting correctly\n(\n)\nand have GPIO and UART working\n(\n).\nMost targets have support for basic peripherals, like I2C, SPI and ADC\n(\n)\nas well as complicated peripherals, like Timers, CAN and external memory\n(\n).\nWe also use a few targets in everyday development, which are very well tested\n(\n).\n\n\nPlease see \nour examples for a complete list\n of tested projects.\n\n\nYour target\n#\n\n\nWhile the xpcc API is designed to be portable, we are only a small team of developers and are limited in the amount of platforms we can support and test in hardware.\nThe following microcontrollers should be able to compile, but \nhave not been tested extensively\n in hardware:\n\n\n\n\nAll AT90 targets\n\n\nAll ATtiny targets\n\n\nAll ATmega targets\n\n\nAll STM32F0 targets\n\n\nAll STM32F1 targets\n\n\nAll STM32F3 targets\n\n\nAll STM32F4 targets\n\n\nAll STM32F7 targets\n\n\n\n\nThere are more platforms which we have prepared, but currently not finished support for (Xmega, STM32F2, STM32L).\n\nDrop us an email\n to ask if your specific target is supported out-of-the-box and what you can do if it's not.\n\n\nWho we are\n#\n\n\nDuring the last decade the \nRoboterclub Aachen e.V.\n has developed a software library for communication among components that are distributed on PCs and microcontrollers. This library was used in autonomous robots for the \nEurobot competition\n.\n\n\nIn 2009, xpcc became a separate project and since then focussed on a new approach to cross target microcontroller libraries. Over the years xpcc grew from a communication library to a general purpose framework suitable for all kinds of embedded applications.\n\n\nThe xpcc project is maintained by\nNiklas Hauser (\n@salkinium\n) and\nKevin L\u00e4ufer (\n@ekiwi\n) with significant contributions from\nFabian Greif (\n@dergraaf\n),\nDaniel Krebs (\n@daniel-k\n),\n\n@georgi-g\n and\n\n@thundernail\n.\n\n\nHave a look at the quarter finals of the \nEurobot 2015 competition\n.\nBoth our robots are running xpcc and starting from the right:", 
            "title": "Home"
        }, 
        {
            "location": "/#xpcc-c-microcontroller-framework", 
            "text": "The xpcc framework consists of powerful hardware abstraction layers for many\ndifferent microcontrollers, a set of drivers for various external targets and a general purpose toolbox for building hardware orientated applications.  The main goal of xpcc is to provide a usable API for barebone microcontroller programming,\nwhich is efficient enough to be deployed on a small ATtiny, yet powerful enough to make\nuse of advanced capabilities found on the 32bit ARM Cortex-M.  xpcc is  battle-tested  in the real-world, highly competitive\nenvironment of  Eurobot .\nIt is the foundation of all of  @RCA_eV 's robot code, and is the\nculmination of many years worth of effort, experience and improvements.   Feast your eyes on lots of working examples .  API reference is available here .  We have continuous integration as well .  And we care a lot about testing .   This project also has  guide for developers  as well as a  technical blog  to document larger design concepts.   You have questions?  Ask them on our mailing list \nor  have a look at the archive .  You found a bug?  Open up an issue, we don't bite .  You want to contribute?  Read the contribution guidelines  and  open a pull request so we can merge it .  You want to port xpcc?  Read our porting guide .   The source code is freely available under a 3-clause BSD license, so feel\nfree to fork this project and adapt it to your needs.\nThe only thing we ask of you is to contribute your changes back.\nThat way everyone can profit.", 
            "title": "xpcc: C++ microcontroller framework "
        }, 
        {
            "location": "/#features", 
            "text": "Efficient and fast object-oriented C++11 API.  Support of AVR and ARM Cortex-M based microcontrollers from Atmel, ST and NXP.  Build system based on SCons and extendable using Python.  Data-driven HAL generation using Jinja2 template engine.  No memory allocations in HAL with very low overall RAM consumption.  Cross platform peripheral interfaces incl. bit banging:  GPIO   GPIO expanders  ADC  UART, I2C, SPI  CAN    Interfaces for external I2C and SPI device drivers.  Debug/logging system with IOStream interface.  Lightweight, stackless threads and resumable functions using cooperative multitasking.  Useful mathematical and geometric algorithms optimized for microcontrollers.  Lightweight unit testing system (suitable for AVRs).  Graphical user interface for small binary displays.", 
            "title": "Features"
        }, 
        {
            "location": "/#supported-hardware", 
            "text": "Here is a list of supported  and tested  microcontrollers and development boards:     Controller  Development Board  Support      AT90can  custom     ATtiny44a  custom     ATtiny85  custom     ATmega328p  Arduino Uno     STM32F072  STM32F072 Discovery     STM32F100  STM32F1 Discovery     STM32F103  Nucleo F103RB     STM32F103  STM32F1 Blue Pill     STM32F303  STM32F3 Discovery     STM32F303  Nucleo F303K8     STM32F407  STM32F4 Discovery     STM32F411  Nucleo F411RE     STM32F429  STM32F429 Discovery     STM32F429  Nucleo F429ZI     STM32F469  STM32F469 Discovery     STM32F746  STM32F746 Discovery     STM32F769  STM32F769 Discovery     LPC11C24  LPCxpresso      All of these targets are compiling and booting correctly\n( )\nand have GPIO and UART working\n( ).\nMost targets have support for basic peripherals, like I2C, SPI and ADC\n( )\nas well as complicated peripherals, like Timers, CAN and external memory\n( ).\nWe also use a few targets in everyday development, which are very well tested\n( ).  Please see  our examples for a complete list  of tested projects.", 
            "title": "Supported hardware"
        }, 
        {
            "location": "/#your-target", 
            "text": "While the xpcc API is designed to be portable, we are only a small team of developers and are limited in the amount of platforms we can support and test in hardware.\nThe following microcontrollers should be able to compile, but  have not been tested extensively  in hardware:   All AT90 targets  All ATtiny targets  All ATmega targets  All STM32F0 targets  All STM32F1 targets  All STM32F3 targets  All STM32F4 targets  All STM32F7 targets   There are more platforms which we have prepared, but currently not finished support for (Xmega, STM32F2, STM32L). Drop us an email  to ask if your specific target is supported out-of-the-box and what you can do if it's not.", 
            "title": "Your target"
        }, 
        {
            "location": "/#who-we-are", 
            "text": "During the last decade the  Roboterclub Aachen e.V.  has developed a software library for communication among components that are distributed on PCs and microcontrollers. This library was used in autonomous robots for the  Eurobot competition .  In 2009, xpcc became a separate project and since then focussed on a new approach to cross target microcontroller libraries. Over the years xpcc grew from a communication library to a general purpose framework suitable for all kinds of embedded applications.  The xpcc project is maintained by\nNiklas Hauser ( @salkinium ) and\nKevin L\u00e4ufer ( @ekiwi ) with significant contributions from\nFabian Greif ( @dergraaf ),\nDaniel Krebs ( @daniel-k ), @georgi-g  and @thundernail .  Have a look at the quarter finals of the  Eurobot 2015 competition .\nBoth our robots are running xpcc and starting from the right:", 
            "title": "Who we are"
        }, 
        {
            "location": "/why-use-xpcc/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nWhy use xpcc?\n#\n\n\n\n\n\n\n\n\nxpcc is tailored for the harsh requirements of the \nEurobot competition\n,\nwhere our robots need to run reliably and completely autonomously for the games\nduration. Furthermore, our robots started off running on AVRs, so xpcc also\nneeds to be very efficient with its resources to be able to support these tiny\nmicrocontrollers.\nAll in all, this means we need a really robust and safe foundation to build all\nour code upon.\n\n\nThis foundation is xpcc.\nIt runs very reliably and efficiently on AVR as well as ARM Cortex-M cores.\nHere are the reasons why.\n\n\nData-driven design\n#\n\n\nThe most unique thing about xpcc is how we generate our hardware abstraction\nlayer (HAL) drivers.\nWe have assembled the unique meta data of all of our targets, such as number\nand type of peripherals, pins, memories and interrupts.\nThis way we know which devices are similar to each other even before opening the\ndatasheet, and we can make informed decisions about what HAL drivers an entire\n\nfamily\n of devices requires, rather than going through this cumbersome process\nfor each device individually.\n\n\nThis dramatically reduces duplicated code, required a lot less porting effort\nand leads to much higher device coverage of our HAL drivers.\nBy combining the specific device meta data with our driver templates, we\ncollect the similarities and differences between device families in one common\nplace, which makes it so much easier to reason about them.\n\n\nThis extract from the \nSTM32F407 device file\n shows\nseveral types of peripheral drivers as well as additional information like\ninstances and pin alternate functions:\n\n\n...\n\ndriver\n \ntype=\nadc\n \nname=\nstm32\n \ninstances=\n1,2,3\n/\n\n\ndriver\n \ntype=\nclock\n \nname=\nstm32\n/\n\n\ndriver\n \ntype=\ni2c\n \nname=\nstm32\n \ninstances=\n1,2,3\n/\n\n\ndriver\n \ntype=\nuart\n \nname=\nstm32\n \ninstances=\n1,2,3,4,5,6\n/\n\n\ndriver\n \ntype=\ngpio\n \nname=\nstm32\n\n  \ngpio\n \nport=\nA\n \nid=\n0\n\n    \naf\n \nid=\n1\n \nperipheral=\nTimer2\n \nname=\nChannel1\n/\n\n    \naf\n \nid=\n8\n \nperipheral=\nUart4\n \nname=\nTx\n \ntype=\nout\n/\n\n    \naf\n \nperipheral=\nAdc1\n \nname=\nChannel0\n \ntype=\nanalog\n/\n\n  \n/gpio\n\n  ...\n\n\n\n\n\nThis information is then passed to our \nHAL drivers\n, which use\ncode generation tools, specifically the \nJinja2 template engine\n, to\ngenerate the appropriate C++ code structures for the specified target:\n\n:\n:\nA\nD\nC\nT\ne\nm\np\nl\na\nt\ne\nG\np\ni\no\nB\n2\nT\na\nr\ng\ne\nt\nD\ne\nv\ni\nc\ne\nF\ni\nl\ne\nG\nP\nI\nO\nT\ne\nm\np\nl\na\nt\ne\nG\np\ni\no\nB\n3\nI\n2\nC\nT\ne\nm\np\nl\na\nt\ne\nG\np\ni\no\nB\n4\n:\n:\n\n\nThis treasure trove of information is available for \nevery AVR and STM32\ndevice\n we support and gives us a high confidence\nin the quality of our HAL ports.\n\n\nUsable \n fast C++\n#\n\n\nxpcc's APIs are kept simple and fast by splitting up functionality into\nseparate, small, static functions, which implement the same behavior on all\nplatforms.\nFurthermore, with our code generation capabilities, we can hide the crazy\nimplementation details of the hardware without compromising on performance.\n\n\nFor example, on different AVRs, simple things like enabling the internal PullUp resistor,\ndealing with external interrupts or even just toggling a pin is done quite dissimilarly.\nYet, using static inlined functions we can call GPIO functions at \nludicrous speed\n,\nall without using even a single byte of static RAM:\n\n\nusing\n \nLed\n \n=\n \nGpioOutputB1\n;\n   \n// Generated by GPIO HAL driver using meta-data.\n\n\nLed\n::\nsetOutput\n();\n           \n// Sets the pin to output on any platform.\n\n\nLed\n::\nset\n();\n                 \n// Literally 1 instruction on AVR.\n\n\nLed\n::\ntoggle\n();\n              \n// PORTA ^= 0x02;  or  PINA = 0x02;  if available.\n\n\n\nusing\n \nButton\n \n=\n \nGpioInputA0\n;\n \n// All pins behave the same way.\n\n\nButton\n::\nsetInput\n(\nGpio\n::\nInputType\n::\nPullUp\n);\n  \n// PORTA |= 0x01;  or  PUEA |= 0x01;\n\n\nbool\n \nstate\n \n=\n \nButton\n::\nread\n();\n                \n// (PINA \n 0x01)  or\n\n\nButton\n::\nsetInputTrigger\n(\nGpio\n::\nInputTrigger\n::\nRisingEdge\n);\n  \n// Don\nt panic!\n\n\nButton\n::\nenableExternalInterrupt\n();\n          \n// Something, something, EIMSK.\n\n\nButton\n::\nacknowledgeExternalInterruptFlag\n();\n \n// don\nt worry, we will do it!\n\n\n\n\n\n\nYou can use these GPIOs as building blocks for more complex drivers and\nperipherals and still maintain access speed without sacrificing usability:\n\n\n// Create a hardware accelerated port of 4 bit width.\n\n\nusing\n \nPort4\n \n=\n \nGpioPort\n \nGpioC0\n,\n \n4\n \n;\n        \n// MSB -\n C3, C2, C1, C0 \n- LSB\n\n\nusing\n \nReadWrite\n \n=\n \nGpioC4\n;\n                   \n// \nname\n your GPIOs.\n\n\nusing\n \nReset\n \n=\n \nGpioOutputC5\n;\n\n\nusing\n \nEnable\n \n=\n \nGpioOutputC6\n;\n\n\n\n// Build a super fast character display driver using these inlined GPIOs.\n\n\nxpcc\n::\nHd44780\nPort4\n,\n \nReadWrite\n,\n \nReset\n,\n \nEnable\n \ndisplay\n;\n\n\ndisplay\n.\ninitialize\n();\n   \n// driver knows to initialize for a 4 bit bus!\n\n\ndisplay\n \n \nHello World!\n \n \nxpcc\n::\nendl\n;\n    \n// Yes, ostreams. Deal with it.\n\n\n\n\n\n\nAll other HAL drivers are build using these principles, which makes them easy\nto configure and use yet very fast without consuming a lot of resources.\n\n\nStatic allocation\n#\n\n\nNowhere in our HAL do we allocate memory dynamically \u2013 everything is either\nstatically allocated or must explicitly be allocated by the user.\nThis is a strong requirement to be able to run xpcc on AVRs, which have\nlittle if any memory to spare for dynamic allocations.\n\n\nWe took great care to make sure this constraint remains usable, starting with\nconfigurable queue sizes for buffered UART to providing statically extensible\nI2C state machine for custom IC drivers.\nWhen we allocate static memory, we choose an appropriate size for its purpose.\nAfter all, just because you \ncan\n use \nint\n doesn't mean you \nshould\n.\n\n\nWe transparently show you how much static memory your application is using,\nso you get an idea of how much certain functionality costs you in resources.\nThis is the size of the accelerometer example on the STM32F4 discovery board:\n\n\ncd\n examples/stm32f4_discovery/accelerometer\nscons\n\n[\n...\n]\n\nMemory Usage\n------------\nDevice: stm32f407vg\n\nProgram:    \n5372\n bytes \n(\n0.5% used\n)\n\n\n(\n.data + .fastdata + .reset + .rodata + .text\n)\n\n\nData:       \n3380\n bytes \n(\n1.7% used\n)\n \n=\n \n308\n bytes static \n(\n0.2%\n)\n + \n3072\n bytes stack \n(\n1.5%\n)\n\n\n(\n.bss + .data + .fastdata + .noinit + .stack\n)\n\n\nHeap:     \n197324\n bytes \n(\n98.3% available\n)\n\n\n(\n.heap0 + .heap1 + .heap2 + .heap5\n)\n\n\n\n\n\n\nCompile-time assertions\n#\n\n\nxpcc stands out for its extensive use of static C++ classes and templates which\nis unusual in this field, but lends itself well to the static nature of\nembedded development.\nBy combining modern C++11 features like \nconstexpr\n functions with the meta-data\ninside our HAL drivers, we can add additional type checks and move certain\ncomputations into compile-time, with obvious speed and usability improvements.\n\n\nAs an example, consider how xpcc connects GPIOs to peripherals and computes\nbaudrates at compile time\n1\n:\n\n\n// The specific UART connect type is unique to this GPIO.\n\n\nGpioA2\n::\nconnect\n(\nUart0\n::\nTx\n);\n\n\nGpioA3\n::\nconnect\n(\nUart0\n::\nRx\n,\n \nGpio\n::\nInputType\n::\nPullUp\n);\n\n\n// Connecting a type to the wrong GPIO will simply _not compile_!\n\n\nGpioA0\n::\nconnect\n(\nUart0\n::\nTx\n);\n \n\u26a1\n   \n// PA0 does not have this alternate function!\n\n\n\n// Enforce the UART baudrate with a 1% tolerance, otherwise compilation error!\n\n\nUart0\n::\ninitialize\nsystemClock\n,\n \n115200\n();\n   \n// prescalers computed at compile-time\n\n\n\n\n\n\nBy moving these checks into compile time, xpcc can prevent predictable failures\nbefore the code ever makes it to the target, and remove the need for expensive\ncomputations at runtime altogether, which pays off especially on AVRs!\nAnother interesting side effect is that your code \nis\n your documentation, with\nits correctness transparently enforced at compile-time.\n\n\nMultitasking\n#\n\n\nxpcc uses stackless cooperative multitasking, for which we have ported\n\nprotothreads\n to C++ and extended them with \nresumable functions\n.\nThis enables you to split up your application into separate tasks, and use\nsynchronous APIs in all of them, without sacrificing overall responsiveness.\nThis works on even the most resource restricted AVRs, since each task only\nrequires 2 bytes!\n\n\nAll our IC drivers are implemented using resumable functions, which can be\ncalled from within protothreads or explicitly blocking outside of them.\nHere is an example of \nreading out the accelerometer\n:\n\n\nclass\n \nReaderThread\n \n:\n \npublic\n \nxpcc\n::\npt\n::\nProtothread\n\n\n{\n\n\npublic\n:\n\n    \nbool\n \nrun\n()\n\n    \n{\n\n        \nPT_BEGIN\n();\n\n        \n// The driver does several I2C transfer here to initialize and configure the\n\n        \n// external sensor. The CPU is free to do other things while this happens though.\n\n        \nPT_CALL\n(\naccelerometer\n.\nconfigure\n(\naccelerometer\n.\nScale\n::\nG2\n));\n\n\n        \nwhile\n \n(\ntrue\n)\n    \n// this feels quite similar to regular threads\n\n        \n{\n\n            \n// this resumable function will defer execution back to other protothreads\n\n            \nPT_CALL\n(\naccelerometer\n.\nreadAcceleration\n());\n\n\n            \n// smooth out the acceleration data a little bit\n\n            \naverageX\n.\nupdate\n(\naccelerometer\n.\ngetData\n().\ngetX\n());\n\n            \naverageY\n.\nupdate\n(\naccelerometer\n.\ngetData\n().\ngetY\n());\n\n\n            \n// set the boards LEDs depending on the acceleration values\n\n            \nLedUp\n::\nset\n(\n   \naverageX\n.\ngetValue\n()\n \n \n-\n0.2\n);\n\n            \nLedDown\n::\nset\n(\n \naverageX\n.\ngetValue\n()\n \n  \n0.2\n);\n\n            \nLedLeft\n::\nset\n(\n \naverageY\n.\ngetValue\n()\n \n \n-\n0.2\n);\n\n            \nLedRight\n::\nset\n(\naverageY\n.\ngetValue\n()\n \n  \n0.2\n);\n\n\n            \n// defer back to other protothreads until the timer fires\n\n            \nPT_WAIT_UNTIL\n(\ntimer\n.\nexecute\n());\n\n        \n}\n\n        \nPT_END\n();\n\n    \n}\n\n\nprivate\n:\n\n    \n// This accelerometer is connected via I2C.\n\n    \nxpcc\n::\nLis3dsh\n \nxpcc\n::\nLis3TransportI2c\n \nI2cMaster\n \n \n \naccelerometer\n;\n\n    \nxpcc\n::\nPeriodicTimer\n \ntimer\n \n=\n \nxpcc\n::\nPeriodicTimer\n(\n5\n);\n \n// 5ms periodic timer.\n\n    \nxpcc\n::\nfilter\n::\nMovingAverage\nfloat\n,\n \n25\n \naverageX\n;\n\n    \nxpcc\n::\nfilter\n::\nMovingAverage\nfloat\n,\n \n25\n \naverageY\n;\n\n\n};\n\n\nReaderThread\n \nreader\n;\n    \n// Protothread is statically allocated!\n\n\n\nint\n \nmain\n()\n \n// Execution entry point.\n\n\n{\n\n    \nwhile\n(\ntrue\n)\n\n    \n{\n   \n// the main loop with implicit round robin cooperative scheduling.\n\n        \nreader\n.\nrun\n();\n\n        \notherProtothreads\n.\nrun\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComputing and Asserting Baudrate Settings at Compile Time", 
            "title": "Why use xpcc?"
        }, 
        {
            "location": "/why-use-xpcc/#why-use-xpcc", 
            "text": "xpcc is tailored for the harsh requirements of the  Eurobot competition ,\nwhere our robots need to run reliably and completely autonomously for the games\nduration. Furthermore, our robots started off running on AVRs, so xpcc also\nneeds to be very efficient with its resources to be able to support these tiny\nmicrocontrollers.\nAll in all, this means we need a really robust and safe foundation to build all\nour code upon.  This foundation is xpcc.\nIt runs very reliably and efficiently on AVR as well as ARM Cortex-M cores.\nHere are the reasons why.", 
            "title": "Why use xpcc?"
        }, 
        {
            "location": "/why-use-xpcc/#data-driven-design", 
            "text": "The most unique thing about xpcc is how we generate our hardware abstraction\nlayer (HAL) drivers.\nWe have assembled the unique meta data of all of our targets, such as number\nand type of peripherals, pins, memories and interrupts.\nThis way we know which devices are similar to each other even before opening the\ndatasheet, and we can make informed decisions about what HAL drivers an entire family  of devices requires, rather than going through this cumbersome process\nfor each device individually.  This dramatically reduces duplicated code, required a lot less porting effort\nand leads to much higher device coverage of our HAL drivers.\nBy combining the specific device meta data with our driver templates, we\ncollect the similarities and differences between device families in one common\nplace, which makes it so much easier to reason about them.  This extract from the  STM32F407 device file  shows\nseveral types of peripheral drivers as well as additional information like\ninstances and pin alternate functions:  ... driver   type= adc   name= stm32   instances= 1,2,3 /  driver   type= clock   name= stm32 /  driver   type= i2c   name= stm32   instances= 1,2,3 /  driver   type= uart   name= stm32   instances= 1,2,3,4,5,6 /  driver   type= gpio   name= stm32 \n   gpio   port= A   id= 0 \n     af   id= 1   peripheral= Timer2   name= Channel1 / \n     af   id= 8   peripheral= Uart4   name= Tx   type= out / \n     af   peripheral= Adc1   name= Channel0   type= analog / \n   /gpio \n  ...  This information is then passed to our  HAL drivers , which use\ncode generation tools, specifically the  Jinja2 template engine , to\ngenerate the appropriate C++ code structures for the specified target: : : A D C T e m p l a t e G p i o B 2 T a r g e t D e v i c e F i l e G P I O T e m p l a t e G p i o B 3 I 2 C T e m p l a t e G p i o B 4 : :  This treasure trove of information is available for  every AVR and STM32\ndevice  we support and gives us a high confidence\nin the quality of our HAL ports.", 
            "title": "Data-driven design"
        }, 
        {
            "location": "/why-use-xpcc/#usable-fast-c", 
            "text": "xpcc's APIs are kept simple and fast by splitting up functionality into\nseparate, small, static functions, which implement the same behavior on all\nplatforms.\nFurthermore, with our code generation capabilities, we can hide the crazy\nimplementation details of the hardware without compromising on performance.  For example, on different AVRs, simple things like enabling the internal PullUp resistor,\ndealing with external interrupts or even just toggling a pin is done quite dissimilarly.\nYet, using static inlined functions we can call GPIO functions at  ludicrous speed ,\nall without using even a single byte of static RAM:  using   Led   =   GpioOutputB1 ;     // Generated by GPIO HAL driver using meta-data.  Led :: setOutput ();             // Sets the pin to output on any platform.  Led :: set ();                   // Literally 1 instruction on AVR.  Led :: toggle ();                // PORTA ^= 0x02;  or  PINA = 0x02;  if available.  using   Button   =   GpioInputA0 ;   // All pins behave the same way.  Button :: setInput ( Gpio :: InputType :: PullUp );    // PORTA |= 0x01;  or  PUEA |= 0x01;  bool   state   =   Button :: read ();                  // (PINA   0x01)  or  Button :: setInputTrigger ( Gpio :: InputTrigger :: RisingEdge );    // Don t panic!  Button :: enableExternalInterrupt ();            // Something, something, EIMSK.  Button :: acknowledgeExternalInterruptFlag ();   // don t worry, we will do it!   You can use these GPIOs as building blocks for more complex drivers and\nperipherals and still maintain access speed without sacrificing usability:  // Create a hardware accelerated port of 4 bit width.  using   Port4   =   GpioPort   GpioC0 ,   4   ;          // MSB -  C3, C2, C1, C0  - LSB  using   ReadWrite   =   GpioC4 ;                     //  name  your GPIOs.  using   Reset   =   GpioOutputC5 ;  using   Enable   =   GpioOutputC6 ;  // Build a super fast character display driver using these inlined GPIOs.  xpcc :: Hd44780 Port4 ,   ReadWrite ,   Reset ,   Enable   display ;  display . initialize ();     // driver knows to initialize for a 4 bit bus!  display     Hello World!     xpcc :: endl ;      // Yes, ostreams. Deal with it.   All other HAL drivers are build using these principles, which makes them easy\nto configure and use yet very fast without consuming a lot of resources.", 
            "title": "Usable &amp; fast C++"
        }, 
        {
            "location": "/why-use-xpcc/#static-allocation", 
            "text": "Nowhere in our HAL do we allocate memory dynamically \u2013 everything is either\nstatically allocated or must explicitly be allocated by the user.\nThis is a strong requirement to be able to run xpcc on AVRs, which have\nlittle if any memory to spare for dynamic allocations.  We took great care to make sure this constraint remains usable, starting with\nconfigurable queue sizes for buffered UART to providing statically extensible\nI2C state machine for custom IC drivers.\nWhen we allocate static memory, we choose an appropriate size for its purpose.\nAfter all, just because you  can  use  int  doesn't mean you  should .  We transparently show you how much static memory your application is using,\nso you get an idea of how much certain functionality costs you in resources.\nThis is the size of the accelerometer example on the STM32F4 discovery board:  cd  examples/stm32f4_discovery/accelerometer\nscons [ ... ] \nMemory Usage\n------------\nDevice: stm32f407vg\n\nProgram:     5372  bytes  ( 0.5% used )  ( .data + .fastdata + .reset + .rodata + .text ) \n\nData:        3380  bytes  ( 1.7% used )   =   308  bytes static  ( 0.2% )  +  3072  bytes stack  ( 1.5% )  ( .bss + .data + .fastdata + .noinit + .stack ) \n\nHeap:      197324  bytes  ( 98.3% available )  ( .heap0 + .heap1 + .heap2 + .heap5 )", 
            "title": "Static allocation"
        }, 
        {
            "location": "/why-use-xpcc/#compile-time-assertions", 
            "text": "xpcc stands out for its extensive use of static C++ classes and templates which\nis unusual in this field, but lends itself well to the static nature of\nembedded development.\nBy combining modern C++11 features like  constexpr  functions with the meta-data\ninside our HAL drivers, we can add additional type checks and move certain\ncomputations into compile-time, with obvious speed and usability improvements.  As an example, consider how xpcc connects GPIOs to peripherals and computes\nbaudrates at compile time 1 :  // The specific UART connect type is unique to this GPIO.  GpioA2 :: connect ( Uart0 :: Tx );  GpioA3 :: connect ( Uart0 :: Rx ,   Gpio :: InputType :: PullUp );  // Connecting a type to the wrong GPIO will simply _not compile_!  GpioA0 :: connect ( Uart0 :: Tx );   \u26a1     // PA0 does not have this alternate function!  // Enforce the UART baudrate with a 1% tolerance, otherwise compilation error!  Uart0 :: initialize systemClock ,   115200 ();     // prescalers computed at compile-time   By moving these checks into compile time, xpcc can prevent predictable failures\nbefore the code ever makes it to the target, and remove the need for expensive\ncomputations at runtime altogether, which pays off especially on AVRs!\nAnother interesting side effect is that your code  is  your documentation, with\nits correctness transparently enforced at compile-time.", 
            "title": "Compile-time assertions"
        }, 
        {
            "location": "/why-use-xpcc/#multitasking", 
            "text": "xpcc uses stackless cooperative multitasking, for which we have ported protothreads  to C++ and extended them with  resumable functions .\nThis enables you to split up your application into separate tasks, and use\nsynchronous APIs in all of them, without sacrificing overall responsiveness.\nThis works on even the most resource restricted AVRs, since each task only\nrequires 2 bytes!  All our IC drivers are implemented using resumable functions, which can be\ncalled from within protothreads or explicitly blocking outside of them.\nHere is an example of  reading out the accelerometer :  class   ReaderThread   :   public   xpcc :: pt :: Protothread  {  public : \n     bool   run () \n     { \n         PT_BEGIN (); \n         // The driver does several I2C transfer here to initialize and configure the \n         // external sensor. The CPU is free to do other things while this happens though. \n         PT_CALL ( accelerometer . configure ( accelerometer . Scale :: G2 )); \n\n         while   ( true )      // this feels quite similar to regular threads \n         { \n             // this resumable function will defer execution back to other protothreads \n             PT_CALL ( accelerometer . readAcceleration ()); \n\n             // smooth out the acceleration data a little bit \n             averageX . update ( accelerometer . getData (). getX ()); \n             averageY . update ( accelerometer . getData (). getY ()); \n\n             // set the boards LEDs depending on the acceleration values \n             LedUp :: set (     averageX . getValue ()     - 0.2 ); \n             LedDown :: set (   averageX . getValue ()      0.2 ); \n             LedLeft :: set (   averageY . getValue ()     - 0.2 ); \n             LedRight :: set ( averageY . getValue ()      0.2 ); \n\n             // defer back to other protothreads until the timer fires \n             PT_WAIT_UNTIL ( timer . execute ()); \n         } \n         PT_END (); \n     }  private : \n     // This accelerometer is connected via I2C. \n     xpcc :: Lis3dsh   xpcc :: Lis3TransportI2c   I2cMaster       accelerometer ; \n     xpcc :: PeriodicTimer   timer   =   xpcc :: PeriodicTimer ( 5 );   // 5ms periodic timer. \n     xpcc :: filter :: MovingAverage float ,   25   averageX ; \n     xpcc :: filter :: MovingAverage float ,   25   averageY ;  };  ReaderThread   reader ;      // Protothread is statically allocated!  int   main ()   // Execution entry point.  { \n     while ( true ) \n     {     // the main loop with implicit round robin cooperative scheduling. \n         reader . run (); \n         otherProtothreads . run (); \n     }  }       Computing and Asserting Baudrate Settings at Compile Time", 
            "title": "Multitasking"
        }, 
        {
            "location": "/installation/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nInstallation\n#\n\n\nThis is the minimum required software for the xpcc build system:\n\n\n\n\nPython 2.7.x\n\n\nSoftware Construct\n\n\nJinja2 Template Engine\n\n\nAVR toolchain: \navr-gcc\n and \navrdude\n\n\nARM toolchain: \narm-none-eabi-gcc\n and \nopenocd\n\n\n\n\nTo start actively developing on xpcc, you will also need these packages:\n\n\n\n\npython-lxml\n\n\ndoxygen\n\n\n\n\nNote that xpcc requires C++11, so you need a reasonably new compiler (GCC \n4.9).\n\n\nInstalling on Linux\n#\n\n\nFor Ubuntu 14.04LTS, these commands install the basic build system:\n\n\nsudo apt-get install python python-pip python-jinja2 scons git\n\n\n\n\n\nInstall the AVR toochain:\n\n\nsudo apt-get install gcc-avr binutils-avr avr-libc avrdude\n\n\n\n\n\nAnd the ARM toolchain as well:\n\n\nsudo add-apt-repository ppa:team-gcc-arm-embedded/ppa\nsudo apt-get update\nsudo apt-get install gcc-arm-embedded openocd\n\n\n\n\n\nTo compile programs for x86 systems install the following packets:\n\n\nsudo apt-get install gcc build-essential libboost-thread-dev \\\n                     libboost-system-dev libasio-dev\n\n\n\n\n\nFor active xpcc development install these packets too:\n\n\nsudo apt-get --no-install-recommends install doxygen\npip install --user lxml\n\n\n\n\n\nThis installs \ndoxygen\n without LaTeX support, which saves ~600MB of disk space.\n\n\nInstalling on OS X\n#\n\n\nFirst install \nhomebrew\n, a great packet\nmanager for OS X, then use it to install the minimum build system:\n\n\nbrew install python scons git\npip install --user jinja2\n\n\n\n\n\nCompile the \nAVR toolchain from source\n (may take a while):\n\n\nbrew tap osx-cross/avr\nbrew install avr-libc avrdude\n\n\n\n\n\nAnd the ARM toolchain as well:\n\n\nbrew tap ARMmbed/homebrew-formulae\nbrew install arm-none-eabi-gcc\n\n\n\n\n\nTo program and debug your ARM Cortex-M device, you need to install the latest\n\nOpenOCD\n version:\n\n\nbrew install openocd --HEAD --enable-ft2232_libftdi \\\n                     --enable-jlink --enable-stlink\n\n\n\n\n\nFor active xpcc development install these packets too:\n\n\nbrew install doxygen\npip install --user lxml\n\n\n\n\n\nInstalling on Windows\n#\n\n\nWe're sorry, we do not have enough experience with Windows to provide\nhonest support.\n\nPull requests welcome!", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "This is the minimum required software for the xpcc build system:   Python 2.7.x  Software Construct  Jinja2 Template Engine  AVR toolchain:  avr-gcc  and  avrdude  ARM toolchain:  arm-none-eabi-gcc  and  openocd   To start actively developing on xpcc, you will also need these packages:   python-lxml  doxygen   Note that xpcc requires C++11, so you need a reasonably new compiler (GCC  4.9).", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-on-linux", 
            "text": "For Ubuntu 14.04LTS, these commands install the basic build system:  sudo apt-get install python python-pip python-jinja2 scons git  Install the AVR toochain:  sudo apt-get install gcc-avr binutils-avr avr-libc avrdude  And the ARM toolchain as well:  sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa\nsudo apt-get update\nsudo apt-get install gcc-arm-embedded openocd  To compile programs for x86 systems install the following packets:  sudo apt-get install gcc build-essential libboost-thread-dev \\\n                     libboost-system-dev libasio-dev  For active xpcc development install these packets too:  sudo apt-get --no-install-recommends install doxygen\npip install --user lxml  This installs  doxygen  without LaTeX support, which saves ~600MB of disk space.", 
            "title": "Installing on Linux"
        }, 
        {
            "location": "/installation/#installing-on-os-x", 
            "text": "First install  homebrew , a great packet\nmanager for OS X, then use it to install the minimum build system:  brew install python scons git\npip install --user jinja2  Compile the  AVR toolchain from source  (may take a while):  brew tap osx-cross/avr\nbrew install avr-libc avrdude  And the ARM toolchain as well:  brew tap ARMmbed/homebrew-formulae\nbrew install arm-none-eabi-gcc  To program and debug your ARM Cortex-M device, you need to install the latest OpenOCD  version:  brew install openocd --HEAD --enable-ft2232_libftdi \\\n                     --enable-jlink --enable-stlink  For active xpcc development install these packets too:  brew install doxygen\npip install --user lxml", 
            "title": "Installing on OS X"
        }, 
        {
            "location": "/installation/#installing-on-windows", 
            "text": "We're sorry, we do not have enough experience with Windows to provide\nhonest support. Pull requests welcome!", 
            "title": "Installing on Windows"
        }, 
        {
            "location": "/guide/getting-started/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nGetting started\n#\n\n\nExamples\n#\n\n\nThe best way for you to quickly learn about xpcc's APIs is to look at and experiment with \nour examples\n, especially if you have a development board that xpcc \nsupports out-of-the-box\n.\nMake sure you have \nthe toolchain installed\n.\n\n\nHere are our favorite examples for our supported development boards:\n\n\n\n\nArduino Uno:\n\nBlinky\n,\n\nButton \n Serial\n,\n\nAnalog \n Serial\n.\n\n\nNUCLEO-F031K6:\n\nBlinky \n Serial\n.\n\n\nNUCLEO-F103RB:\n\nBlinky \n Serial\n.\n\n\nSTM32F072 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nGyroscope\n.\n\n\nSTM32F3 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nAccelerometer\n,\n\nGyroscope\n,\n\nDebugging with GDB\n.\n\n\nSTM32F4 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nAccelerometer\n,\n\nTimer \n LED Animations\n,\n\nDebugging hard faults\n.\n\n\nSTM32F469 Discovery:\n\nBlinky\n,\n\nDrawing on display\n,\n\nTouchscreen inputs\n,\n\nMulti-heap with external 16MB memory\n,\n\nGame of Life in Color with Multitouch\n\n\nSTM32F769 Discovery:\n\nFPU with double precision\n\n\n\n\nHere are some additional examples of displays and sensors we like:\n\n\n\n\nSSD1306 OLED display\n: Draws text and graphics onto I2C display.\n\n\nBMP085/BMP180 barometer\n: Reads atmospheric pressure and temperature from I2C sensor.\n\n\nBMP180/BME280 barometer\n: Reads atmospheric pressure and temperature from multiple I2C sensors.\n\n\nVL6180 time-of-flight distance sensor\n: Reads distance and ambient light from I2C sensor.\n\n\nVL53L0  time-of-flight distance sensor\n: Much improved version of the VL6180 sensor.\n\n\nADNS9800 motion sensor\n: Reads 2D motion from SPI sensor used in gaming mice.\n\n\nTCS3414 color sensor\n: Reads RGB color from I2C sensor.\n\n\nHD44780 over I2C-GPIO expander\n: Draws text via native GPIO port or I2C-GPIO expander port onto character display.\n\n\n\n\nHave a look at \nthe build system commands\n to see how\nto compile and program your targets.\n\n\nYour own project\n#\n\n\nStart your own project by cloning \nour \ngetting-started\n project\n from GitHub:\n\n\ngit clone --recursive https://github.com/roboterclubaachen/getting-started-with-xpcc.git\n\ncd\n getting-started-with-xpcc\ntree\n.\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 hello-world\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SConstruct\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 main.cpp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 project.cfg\n\u2514\u2500\u2500 xpcc \n(\ngit submodule\n)\n\n\n\n\n\n\nThe example contains the xpcc framework as a git submodule, a \nSConstruct\n file for \nour build system\n,\na project configuration file and of course the source code:\n\n\n#include\n \nxpcc/architecture/platform.hpp\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nBoard\n::\ninitialize\n();\n\n    \nBoard\n::\nLeds\n::\nsetOutput\n();\n\n\n    \nwhile\n \n(\n1\n)\n\n    \n{\n\n        \nBoard\n::\nLeds\n::\ntoggle\n();\n\n        \nxpcc\n::\ndelayMilliseconds\n(\nBoard\n::\nButton\n::\nread\n()\n \n?\n \n250\n \n:\n \n500\n);\n\n\n#ifdef XPCC_BOARD_HAS_LOGGER\n\n        \nstatic\n \nuint32_t\n \ncounter\n(\n0\n);\n\n        \nXPCC_LOG_INFO\n \n \nLoop counter: \n \n \n(\ncounter\n++\n)\n \n \nxpcc\n::\nendl\n;\n\n\n#endif\n\n    \n}\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nYou can change the development board for which you want to compile the example\nfor in the \nproject.cfg\n file:\n\n\n[build]\n\n\nboard\n \n=\n \nstm32f4_discovery\n\n\n#board = arduino_uno\n\n\n#board = nucleo_f103rb\n\n\n#board = stm32f072_discovery\n\n\n#board = stm32f1_discovery\n\n\n#board = stm32f3_discovery\n\n\n#board = stm32f429_discovery\n\n\n#board = stm32f469_discovery\n\n\n#board = stm32f7_discovery\n\n\n\n\n\n\nWhen you create you own project, you need to adapt the \nxpccpath\n inside the\n\nSConstruct\n to point to the location of the xpcc framework.\nNote that this allows you to use different versions of the xpcc frameworks\n(your own fork?) for your projects.\n\n\n# path to the xpcc root directory (modify as needed!)\n\n\nxpccpath\n \n=\n \n../xpcc\n\n\n# execute the common SConstruct file\n\n\nexecfile\n(\nxpccpath\n \n+\n \n/scons/SConstruct\n)\n\n\n\n\n\n\nShow me the basics\n#\n\n\nAll of this code works the same on all platforms, however, the pin and module\nnames may need to be adapted.\n\n\nGPIO\n#\n\n\nusing\n \nLed\n \n=\n \nGpioOutputB0\n;\n\n\nLed\n::\nsetOutput\n();\n\n\nLed\n::\nset\n();\n    \n// 1 instruction on AVR\n\n\nLed\n::\nreset\n();\n  \n// 3 instructions on Cortex-M\n\n\nLed\n::\ntoggle\n();\n\n\n\nusing\n \nButton\n \n=\n \nGpioInputB0\n;\n\n\nButton\n::\nsetInput\n(\nGpio\n::\nInputType\n::\nPullUp\n);\n\n\nbool\n \nstate\n \n=\n \nButton\n::\nread\n();\n\n\n\n\n\n\nBuffered UART\n#\n\n\nusing\n \nUart\n \n=\n \nUart0\n;\n\n\n// configure and initialize UART to 115.2kBaud\n\n\nGpioOutputD1\n::\nconnect\n(\nUart\n::\nTx\n);\n\n\nGpioInputD0\n::\nconnect\n(\nUart\n::\nRx\n);\n\n\nUart\n::\ninitialize\nsystemClock\n,\n \n115200\n();\n\n\n\nUart\n::\nwrite\n(\nH\n);\n  \n// Ohai there\n\n\nUart\n::\nwrite\n(\ni\n);\n\n\n\nuint8_t\n \nbuffer\n;\n\n\nwhile\n(\n1\n)\n \n{\n\n    \n// create a simple loopback\n\n    \nif\n \n(\nUart\n::\nread\n(\nbuffer\n))\n \n{\n\n        \nUart\n::\nwrite\n(\nbuffer\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIOStream\n#\n\n\nusing\n \nUart\n \n=\n \nUart0\n;\n\n\n// Create a IODevice with the Uart\n\n\nxpcc\n::\nIODeviceWrapper\nUart\n \ndevice\n;\n\n\nxpcc\n::\nIOStream\n \nstream\n(\ndevice\n);\n\n\n\nGpioOutputD1\n::\nconnect\n(\nUart\n::\nTx\n);\n\n\nUart\n::\ninitialize\nsystemClock\n,\n \n115200\n();\n\n\n\nstream\n \n \n42\n \n \n is a nice number!\n \n \nxpcc\n::\nendl\n;\n\n\n\n\n\n\nSoftware Timers\n#\n\n\nusing\n \nLed\n \n=\n \nGpioOutputB0\n;\n\n\nxpcc\n::\nTimeout\n \ntimeout\n(\n10000\n);\n   \n// 10s timeout\n\n\nxpcc\n::\nPeriodicTimer\n \ntimer\n(\n250\n);\n \n// 250ms period\n\n\n\nLed\n::\nsetOutput\n(\nxpcc\n::\nGpio\n::\nHigh\n);\n\n\n\nwhile\n(\n1\n)\n \n{\n\n    \nif\n \n(\ntimeout\n.\nexecute\n())\n \n{\n\n        \ntimer\n.\nstop\n();\n\n        \nLed\n::\nreset\n();\n\n    \n}\n\n    \nif\n \n(\ntimer\n.\nexecute\n())\n \n{\n\n        \nLed\n::\ntoggle\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nHave a look at the \nxpcc/examples/\n folder\n for more advanced use cases.", 
            "title": "Getting started"
        }, 
        {
            "location": "/guide/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/guide/getting-started/#examples", 
            "text": "The best way for you to quickly learn about xpcc's APIs is to look at and experiment with  our examples , especially if you have a development board that xpcc  supports out-of-the-box .\nMake sure you have  the toolchain installed .  Here are our favorite examples for our supported development boards:   Arduino Uno: Blinky , Button   Serial , Analog   Serial .  NUCLEO-F031K6: Blinky   Serial .  NUCLEO-F103RB: Blinky   Serial .  STM32F072 Discovery: Blinky , CAN , Gyroscope .  STM32F3 Discovery: Blinky , CAN , Accelerometer , Gyroscope , Debugging with GDB .  STM32F4 Discovery: Blinky , CAN , Accelerometer , Timer   LED Animations , Debugging hard faults .  STM32F469 Discovery: Blinky , Drawing on display , Touchscreen inputs , Multi-heap with external 16MB memory , Game of Life in Color with Multitouch  STM32F769 Discovery: FPU with double precision   Here are some additional examples of displays and sensors we like:   SSD1306 OLED display : Draws text and graphics onto I2C display.  BMP085/BMP180 barometer : Reads atmospheric pressure and temperature from I2C sensor.  BMP180/BME280 barometer : Reads atmospheric pressure and temperature from multiple I2C sensors.  VL6180 time-of-flight distance sensor : Reads distance and ambient light from I2C sensor.  VL53L0  time-of-flight distance sensor : Much improved version of the VL6180 sensor.  ADNS9800 motion sensor : Reads 2D motion from SPI sensor used in gaming mice.  TCS3414 color sensor : Reads RGB color from I2C sensor.  HD44780 over I2C-GPIO expander : Draws text via native GPIO port or I2C-GPIO expander port onto character display.   Have a look at  the build system commands  to see how\nto compile and program your targets.", 
            "title": "Examples"
        }, 
        {
            "location": "/guide/getting-started/#your-own-project", 
            "text": "Start your own project by cloning  our  getting-started  project  from GitHub:  git clone --recursive https://github.com/roboterclubaachen/getting-started-with-xpcc.git cd  getting-started-with-xpcc\ntree\n.\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 hello-world\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 SConstruct\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 main.cpp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 project.cfg\n\u2514\u2500\u2500 xpcc  ( git submodule )   The example contains the xpcc framework as a git submodule, a  SConstruct  file for  our build system ,\na project configuration file and of course the source code:  #include   xpcc/architecture/platform.hpp  int   main ()  { \n     Board :: initialize (); \n     Board :: Leds :: setOutput (); \n\n     while   ( 1 ) \n     { \n         Board :: Leds :: toggle (); \n         xpcc :: delayMilliseconds ( Board :: Button :: read ()   ?   250   :   500 );  #ifdef XPCC_BOARD_HAS_LOGGER \n         static   uint32_t   counter ( 0 ); \n         XPCC_LOG_INFO     Loop counter:      ( counter ++ )     xpcc :: endl ;  #endif \n     } \n     return   0 ;  }   You can change the development board for which you want to compile the example\nfor in the  project.cfg  file:  [build]  board   =   stm32f4_discovery  #board = arduino_uno  #board = nucleo_f103rb  #board = stm32f072_discovery  #board = stm32f1_discovery  #board = stm32f3_discovery  #board = stm32f429_discovery  #board = stm32f469_discovery  #board = stm32f7_discovery   When you create you own project, you need to adapt the  xpccpath  inside the SConstruct  to point to the location of the xpcc framework.\nNote that this allows you to use different versions of the xpcc frameworks\n(your own fork?) for your projects.  # path to the xpcc root directory (modify as needed!)  xpccpath   =   ../xpcc  # execute the common SConstruct file  execfile ( xpccpath   +   /scons/SConstruct )", 
            "title": "Your own project"
        }, 
        {
            "location": "/guide/getting-started/#show-me-the-basics", 
            "text": "All of this code works the same on all platforms, however, the pin and module\nnames may need to be adapted.", 
            "title": "Show me the basics"
        }, 
        {
            "location": "/guide/getting-started/#gpio", 
            "text": "using   Led   =   GpioOutputB0 ;  Led :: setOutput ();  Led :: set ();      // 1 instruction on AVR  Led :: reset ();    // 3 instructions on Cortex-M  Led :: toggle ();  using   Button   =   GpioInputB0 ;  Button :: setInput ( Gpio :: InputType :: PullUp );  bool   state   =   Button :: read ();", 
            "title": "GPIO"
        }, 
        {
            "location": "/guide/getting-started/#buffered-uart", 
            "text": "using   Uart   =   Uart0 ;  // configure and initialize UART to 115.2kBaud  GpioOutputD1 :: connect ( Uart :: Tx );  GpioInputD0 :: connect ( Uart :: Rx );  Uart :: initialize systemClock ,   115200 ();  Uart :: write ( H );    // Ohai there  Uart :: write ( i );  uint8_t   buffer ;  while ( 1 )   { \n     // create a simple loopback \n     if   ( Uart :: read ( buffer ))   { \n         Uart :: write ( buffer ); \n     }  }", 
            "title": "Buffered UART"
        }, 
        {
            "location": "/guide/getting-started/#iostream", 
            "text": "using   Uart   =   Uart0 ;  // Create a IODevice with the Uart  xpcc :: IODeviceWrapper Uart   device ;  xpcc :: IOStream   stream ( device );  GpioOutputD1 :: connect ( Uart :: Tx );  Uart :: initialize systemClock ,   115200 ();  stream     42      is a nice number!     xpcc :: endl ;", 
            "title": "IOStream"
        }, 
        {
            "location": "/guide/getting-started/#software-timers", 
            "text": "using   Led   =   GpioOutputB0 ;  xpcc :: Timeout   timeout ( 10000 );     // 10s timeout  xpcc :: PeriodicTimer   timer ( 250 );   // 250ms period  Led :: setOutput ( xpcc :: Gpio :: High );  while ( 1 )   { \n     if   ( timeout . execute ())   { \n         timer . stop (); \n         Led :: reset (); \n     } \n     if   ( timer . execute ())   { \n         Led :: toggle (); \n     }  }   Have a look at the  xpcc/examples/  folder  for more advanced use cases.", 
            "title": "Software Timers"
        }, 
        {
            "location": "/guide/qtcreator/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nQt Creator integration\n#\n\n\nThis tutorial shows how to adapt the Qt Creator IDE for comfortable developing and debugging of xpcc projects on STM32 microcontrollers.\n\n\nThis tutorial uses xpcc\u2019s \nhello-world\n example project of \nour \ngetting-started-with-xpcc\n repository\n for the STM32F4 Discovery board.\n\n\nInstallation\n#\n\n\nInstall \nQt Creator version 4.0 or above\n.\n\n\n# On Fedora 22 and up\nsudo dnf install qtcreator\n# On OS X\nbrew cask install qtcreator\n\n\n\n\n\nGlobal setup\n#\n\n\nEnable Bare Metal plugin\n#\n\n\nOS X: \nQt Creator\n \u2192 \nAbout Plugins...\n\nLinux: \nHelp\n \u2192 \nAbout Plugins...\n\n\n\n\nEnable the BareMetal plugin and restart Qt Creator.\n\n\nCode Style\n#\n\n\nOS X: \nQt Creator\n \u2192 \nPreferences...\n\nLinux: Go to \nOptions\n dialog: \nTools\n \u2192 \nOptions...\n\n\nGo to Tab \nC++\n, create a copy of the \nQt [builtin]\n code style, name it \nxpcc\n and click \nEdit...\n.\n\n\nSet \nTab policy\n to \nTabs only\n, save and exit.\n\n\nAdd debugger\n#\n\n\nIn \nBuild \n Run\n and sub-tab \nDebuggers\n click \nAdd\n to add the \narm-none-eabi-gdb\n debugger to Qt Creator:\n\n\nQt Creator requires the debugger to support Python scripting. If you use the precompiled \narm-none-eabi toolchain from ARM\n you need to use \narm-none-eabi-gdb-py\n here!\n\n\nFor Linux distributions that ship the toolchain themselves and have Python scripting  enabled by default, you can use \n/usr/bin/arm-none-eabi-gdb\n (without the \n-py\n).\n\n\nAdd OpenOCD server\n#\n\n\nGo to tab \nBare Metal\n and select \nAdd\n \u2192 \nOpenOCD\n.\n\n\n\n\n\nUse the following settings:\n\n\n\n\nStartup mode: \nStartup in TCP/IP Mode\n\n\nExecutable file: Path to OpenOCD binary: \n/usr/local/bin/openocd\n (OS X), or \n/usr/bin/openocd\n (Linux)\n\n\nRoot scripts directory: Absolute path to OpenOCD script directory: \n/usr/local/share/openocd/scripts\n (OS X), or \n/usr/share/openocd/scripts\n (Linux)\n\n\nConfiguration File: \nboard/stm32f4discovery.cfg\n\n\n\n\nIf you want to use other targets, create an \nOpenOCD provider\n, \nDevice\n and \nKit\n for each or them.\nHave a look at the OpenOCD script directory to find a configuration file for your target.\n\n\nAdd target device\n#\n\n\nFor the next step go to the \nDevices\n tab and \nAdd...\n a new \nBare Metal Device\n.\n\n\nUse the following settings:\n\n\nAgain, go to tab \nBuild \n Run\n, sub-tab \nKits\n and click \nAdd\n to add a new so called Kit.\n\n\n\n\n\nDevice type: \nBare Metal Device\n\n\nDevice: \nSTM32F4-DISCO\n (the device we just created)\n\n\nCompiler: Irrelevant, we won't use it.\n\n\nDebugger: \narm-none-eabi-gdb\n\n\nQt version: \nNone\n\n\n\n\nClick \nOk\n.\n\n\nxpcc project setup\n#\n\n\nCheck out the getting started repository:\n\n\ngit clone --recursive https://github.com/roboterclubaachen/getting-started-with-xpcc.git\n\n\n\n\n\nChange to the project folder and run \nscons qtcreator\n to generate the Qt creator project files for the xpcc project:\n\n\ncd\n getting-started-with-xpcc/hello-world\nscons qtcreator\n\nscons: Reading SConscript files ...\nscons: \ndone\n reading SConscript files.\nscons: Building targets ...\nTemplate: \ngetting-started-with-xpcc/xpcc/templates/qtcreator/project.creator.in\n to \nhello-world.creator\n\nTemplate: \ngetting-started-with-xpcc/xpcc/templates/qtcreator/project.config.in\n to \nhello-world.config\n\nTemplate: \ngetting-started-with-xpcc/xpcc/templates/qtcreator/project.files.in\n to \nhello-world.files\n\nTemplate: \ngetting-started-with-xpcc/xpcc/templates/qtcreator/project.includes.in\n to \nhello-world.includes\n\nscons: \ndone\n building targets.\n\n\n\n\n\nOpen project with Qt Creator: \nFile\n \u2192 \nOpen File or Project\n\n\n\n\n\nSelect the \nProjects\n view from the \nMode Selector\n on the left side (\nWindow\n \u2192 \nShow Mode Selector\n if not visible).\n\n\nFirst, click \nAdd Kit\n \u2192 \nSTM32F4-DISCO\n, then remove the created \nDefault\n using the icon to the right of it: \nDefault\n \u2192 \nRemove Kit\n.\n\n\n\nNext go to the \nBuild Settings\n and remove all existing \nBuild Steps\n and \nClean Steps\n and:\n\n\n\n\nadd a new \nCustom Process Step\n build step with command \nscons\n and argument \nprogram\n.\n\n\nadd a new \nCustom Process Step\n clean step with command \nscons\n and argument \n-c\n.\n\n\nadd a custom \nPATH\n to the \nSystem Environment\n, if you need to.\n\n\n\n\n\nSwitch to \nRun Settings\n and select \nRun on GDB server or hardware debugger\n as \nRun Configuration\n. Select the *\n.elf\n-file as executable.\n\n\n\nCongratulations, you can now compile, program and debug your xpcc application comfortably in Qt Creator.", 
            "title": "Qt Creator"
        }, 
        {
            "location": "/guide/qtcreator/#qt-creator-integration", 
            "text": "This tutorial shows how to adapt the Qt Creator IDE for comfortable developing and debugging of xpcc projects on STM32 microcontrollers.  This tutorial uses xpcc\u2019s  hello-world  example project of  our  getting-started-with-xpcc  repository  for the STM32F4 Discovery board.", 
            "title": "Qt Creator integration"
        }, 
        {
            "location": "/guide/qtcreator/#installation", 
            "text": "Install  Qt Creator version 4.0 or above .  # On Fedora 22 and up\nsudo dnf install qtcreator\n# On OS X\nbrew cask install qtcreator", 
            "title": "Installation"
        }, 
        {
            "location": "/guide/qtcreator/#global-setup", 
            "text": "", 
            "title": "Global setup"
        }, 
        {
            "location": "/guide/qtcreator/#enable-bare-metal-plugin", 
            "text": "OS X:  Qt Creator  \u2192  About Plugins... \nLinux:  Help  \u2192  About Plugins...   Enable the BareMetal plugin and restart Qt Creator.", 
            "title": "Enable Bare Metal plugin"
        }, 
        {
            "location": "/guide/qtcreator/#code-style", 
            "text": "OS X:  Qt Creator  \u2192  Preferences... \nLinux: Go to  Options  dialog:  Tools  \u2192  Options...  Go to Tab  C++ , create a copy of the  Qt [builtin]  code style, name it  xpcc  and click  Edit... . \nSet  Tab policy  to  Tabs only , save and exit.", 
            "title": "Code Style"
        }, 
        {
            "location": "/guide/qtcreator/#add-debugger", 
            "text": "In  Build   Run  and sub-tab  Debuggers  click  Add  to add the  arm-none-eabi-gdb  debugger to Qt Creator: \nQt Creator requires the debugger to support Python scripting. If you use the precompiled  arm-none-eabi toolchain from ARM  you need to use  arm-none-eabi-gdb-py  here!  For Linux distributions that ship the toolchain themselves and have Python scripting  enabled by default, you can use  /usr/bin/arm-none-eabi-gdb  (without the  -py ).", 
            "title": "Add debugger"
        }, 
        {
            "location": "/guide/qtcreator/#add-openocd-server", 
            "text": "Go to tab  Bare Metal  and select  Add  \u2192  OpenOCD .   Use the following settings:   Startup mode:  Startup in TCP/IP Mode  Executable file: Path to OpenOCD binary:  /usr/local/bin/openocd  (OS X), or  /usr/bin/openocd  (Linux)  Root scripts directory: Absolute path to OpenOCD script directory:  /usr/local/share/openocd/scripts  (OS X), or  /usr/share/openocd/scripts  (Linux)  Configuration File:  board/stm32f4discovery.cfg   If you want to use other targets, create an  OpenOCD provider ,  Device  and  Kit  for each or them.\nHave a look at the OpenOCD script directory to find a configuration file for your target.", 
            "title": "Add OpenOCD server"
        }, 
        {
            "location": "/guide/qtcreator/#add-target-device", 
            "text": "For the next step go to the  Devices  tab and  Add...  a new  Bare Metal Device . \nUse the following settings: \nAgain, go to tab  Build   Run , sub-tab  Kits  and click  Add  to add a new so called Kit.   Device type:  Bare Metal Device  Device:  STM32F4-DISCO  (the device we just created)  Compiler: Irrelevant, we won't use it.  Debugger:  arm-none-eabi-gdb  Qt version:  None   Click  Ok .", 
            "title": "Add target device"
        }, 
        {
            "location": "/guide/qtcreator/#xpcc-project-setup", 
            "text": "Check out the getting started repository:  git clone --recursive https://github.com/roboterclubaachen/getting-started-with-xpcc.git  Change to the project folder and run  scons qtcreator  to generate the Qt creator project files for the xpcc project:  cd  getting-started-with-xpcc/hello-world\nscons qtcreator\n\nscons: Reading SConscript files ...\nscons:  done  reading SConscript files.\nscons: Building targets ...\nTemplate:  getting-started-with-xpcc/xpcc/templates/qtcreator/project.creator.in  to  hello-world.creator \nTemplate:  getting-started-with-xpcc/xpcc/templates/qtcreator/project.config.in  to  hello-world.config \nTemplate:  getting-started-with-xpcc/xpcc/templates/qtcreator/project.files.in  to  hello-world.files \nTemplate:  getting-started-with-xpcc/xpcc/templates/qtcreator/project.includes.in  to  hello-world.includes \nscons:  done  building targets.  Open project with Qt Creator:  File  \u2192  Open File or Project   \nSelect the  Projects  view from the  Mode Selector  on the left side ( Window  \u2192  Show Mode Selector  if not visible).  First, click  Add Kit  \u2192  STM32F4-DISCO , then remove the created  Default  using the icon to the right of it:  Default  \u2192  Remove Kit .  Next go to the  Build Settings  and remove all existing  Build Steps  and  Clean Steps  and:   add a new  Custom Process Step  build step with command  scons  and argument  program .  add a new  Custom Process Step  clean step with command  scons  and argument  -c .  add a custom  PATH  to the  System Environment , if you need to.   \nSwitch to  Run Settings  and select  Run on GDB server or hardware debugger  as  Run Configuration . Select the * .elf -file as executable.  Congratulations, you can now compile, program and debug your xpcc application comfortably in Qt Creator.", 
            "title": "xpcc project setup"
        }, 
        {
            "location": "/guide/testing/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nTesting xpcc\n#\n\n\nxpcc has seen some significant changes in the past and the level of\nmaturity varies between \"does not compile\" and \"very reliable\".\n\n\nThere are different explicit and implicit test strategies in place for\ntesting xpcc.\n\n\nManual tests\n#\n\n\nWhen some new drivers were developed the developer often (not always!) tests the new driver with some real hardware (eval board) and a real peripheral at least on one platform with one compiler. The results on different platforms (AVR instead of ARM) and different hardware (eval board) may vary, although by design should not.\n\n\nMostly, these tests are only conducted when the development takes place.\n\n\nManual integration tests\n#\n\n\nxpcc is the major platform for all programming efforts of the Robot Association Aachen (Roboterclub Aachen, RCA) at RWTH Aachen University. Some parts of xpcc run on real robots in real competitions. The maturity of these parts at least for RCA's hardware can be expected to be very high. This includes:\n\n\n\n\nThe XPCC communication protocol\n\n\nThe target platforms used in the specific season, e.g.\n\n\nSTM32F407 in seasons 2014ff, but only under very specific test conditions, e.g.\n\n\nexternal 8 MHz oscillator\n\n\ncore running at 168 MHz\n\n\nonly using UART0, not UART1\n\n\n\n\n\n\nthe hardware drivers build in the robots (e.g. CAN, VL6180, ...)\n\n\n\n\nThe test coverage is unknown but the system has proved to be reliable under conditions of the competition. Nevertheless, some unforseen problems may still occur at any time. Always fasten your seatbelt.\n\n\nContinous integration\n#\n\n\nxpcc on Github uses TravisCI for CI. A set of test jobs is run with every commit. These include release tests and unit tests.\n\n\nRelease test\n#\n\n\nxpcc covers many different platforms and a huge number of chips. To make sure that at the code at least compiles for all platforms a TravisCI test job is in place as part of the Continous Integration. This only tests compiling on the TravisCI Linux virtual machine. Compiling may fail with different compilers and on different hosts.\n\n\nTo check if simple programs compile for a large set of microcontrollers call\n\n\nscons check=devices\n\n\n\n\n\nThe test programs that are compiled are located in \nxpcc/release/tests\n and differ for each platform.\n\n\nTo compile all examples from \nxpcc/examples\n, run\n\n\nscons check=examples\n\n\n\n\n\nThis does \nnot\n include actually running the examples.\n\n\nTo compile device checks and examples simply run\n\n\nscons check\n\n\n\n\n\nUnit tests on hosted\n#\n\n\nSome parts of xpcc which do not access hardware directly (like communication protocols, mathematical and logical functions) are tested with a xpcc specific unit test framework.\n\n\nTests can be found in the \ntest\n direcotry of each component, e.g. \nxpcc/src/xpcc/math/filter/test\n. These test check for logic errors in the components. They are compiled for the targed \nhosted\n (your computer) and run to check the expected result against a predifined and expected result. The test coverage of these tests vary.\n\n\nEvery new software component is expected to have these checks in place when contributed to xpcc.\n\n\nUnit tests for hosted can be run with\n\n\nscons unittest\n\n\n\n\n\nUnit tests on target\n#\n\n\nA very unique feature of the xpcc unit test framework is that the unit tests can be run on the target platform. This matters because in most cases xpcc is used for cross compiling and the target platform differs at least in one of the following features:\n\n\n\n\ncompiler\n\n\ngcc/clang for x86 vs. arm-none-eabi-gcc vs. avr-gcc\n\n\nword size\n\n\n64 bits vs. 8 bits or 32 bits\n\n\npresence of a FPU\n\n\ni7 vs. AVR vs. ARM Cortex-M4f\n\n\n\n\nTo cross-compile the set of unit tests for STM32 run\n\n\nscons unittest target=stm32\n\n\n\n\n\nThis will create a binary \nxpcc/build/unittest_stm32/executable.elf\n that can be manually programmed to STM32 F4 Discovery board. After reset, the unit tests are run and the result of the test is echoed to the serial console (USART2 in case of the STM32 F4 Discovery Board, see runner.cpp for details). The test runner is created from \nxpcc/templates/unittest/runner_stm32.cpp.in\n and located in \nxpcc/build/unittest_stm32/runner.cpp\n\n\nThese tests are not automatically run and must therefore be run and interpreted manually from time to time.\n\n\nAll platform and hardware drivers still lack these kind of tests, including external stimuli and waveform verification.\n\n\nscons unittest target=atmega\nscons unittest target=atxmega\n\n\n\n\n\nConclusions and Outlook\n#\n\n\nxpcc has a varity of testing strategies in place, is being used on a regular basis by Roboterclub Aachen e. V., receives updates and bug fixes frequently and test coverage is constantly improved.", 
            "title": "Testing"
        }, 
        {
            "location": "/guide/testing/#testing-xpcc", 
            "text": "xpcc has seen some significant changes in the past and the level of\nmaturity varies between \"does not compile\" and \"very reliable\".  There are different explicit and implicit test strategies in place for\ntesting xpcc.", 
            "title": "Testing xpcc"
        }, 
        {
            "location": "/guide/testing/#manual-tests", 
            "text": "When some new drivers were developed the developer often (not always!) tests the new driver with some real hardware (eval board) and a real peripheral at least on one platform with one compiler. The results on different platforms (AVR instead of ARM) and different hardware (eval board) may vary, although by design should not.  Mostly, these tests are only conducted when the development takes place.", 
            "title": "Manual tests"
        }, 
        {
            "location": "/guide/testing/#manual-integration-tests", 
            "text": "xpcc is the major platform for all programming efforts of the Robot Association Aachen (Roboterclub Aachen, RCA) at RWTH Aachen University. Some parts of xpcc run on real robots in real competitions. The maturity of these parts at least for RCA's hardware can be expected to be very high. This includes:   The XPCC communication protocol  The target platforms used in the specific season, e.g.  STM32F407 in seasons 2014ff, but only under very specific test conditions, e.g.  external 8 MHz oscillator  core running at 168 MHz  only using UART0, not UART1    the hardware drivers build in the robots (e.g. CAN, VL6180, ...)   The test coverage is unknown but the system has proved to be reliable under conditions of the competition. Nevertheless, some unforseen problems may still occur at any time. Always fasten your seatbelt.", 
            "title": "Manual integration tests"
        }, 
        {
            "location": "/guide/testing/#continous-integration", 
            "text": "xpcc on Github uses TravisCI for CI. A set of test jobs is run with every commit. These include release tests and unit tests.", 
            "title": "Continous integration"
        }, 
        {
            "location": "/guide/testing/#release-test", 
            "text": "xpcc covers many different platforms and a huge number of chips. To make sure that at the code at least compiles for all platforms a TravisCI test job is in place as part of the Continous Integration. This only tests compiling on the TravisCI Linux virtual machine. Compiling may fail with different compilers and on different hosts.  To check if simple programs compile for a large set of microcontrollers call  scons check=devices  The test programs that are compiled are located in  xpcc/release/tests  and differ for each platform.  To compile all examples from  xpcc/examples , run  scons check=examples  This does  not  include actually running the examples.  To compile device checks and examples simply run  scons check", 
            "title": "Release test"
        }, 
        {
            "location": "/guide/testing/#unit-tests-on-hosted", 
            "text": "Some parts of xpcc which do not access hardware directly (like communication protocols, mathematical and logical functions) are tested with a xpcc specific unit test framework.  Tests can be found in the  test  direcotry of each component, e.g.  xpcc/src/xpcc/math/filter/test . These test check for logic errors in the components. They are compiled for the targed  hosted  (your computer) and run to check the expected result against a predifined and expected result. The test coverage of these tests vary.  Every new software component is expected to have these checks in place when contributed to xpcc.  Unit tests for hosted can be run with  scons unittest", 
            "title": "Unit tests on hosted"
        }, 
        {
            "location": "/guide/testing/#unit-tests-on-target", 
            "text": "A very unique feature of the xpcc unit test framework is that the unit tests can be run on the target platform. This matters because in most cases xpcc is used for cross compiling and the target platform differs at least in one of the following features:   compiler  gcc/clang for x86 vs. arm-none-eabi-gcc vs. avr-gcc  word size  64 bits vs. 8 bits or 32 bits  presence of a FPU  i7 vs. AVR vs. ARM Cortex-M4f   To cross-compile the set of unit tests for STM32 run  scons unittest target=stm32  This will create a binary  xpcc/build/unittest_stm32/executable.elf  that can be manually programmed to STM32 F4 Discovery board. After reset, the unit tests are run and the result of the test is echoed to the serial console (USART2 in case of the STM32 F4 Discovery Board, see runner.cpp for details). The test runner is created from  xpcc/templates/unittest/runner_stm32.cpp.in  and located in  xpcc/build/unittest_stm32/runner.cpp  These tests are not automatically run and must therefore be run and interpreted manually from time to time.  All platform and hardware drivers still lack these kind of tests, including external stimuli and waveform verification.  scons unittest target=atmega\nscons unittest target=atxmega", 
            "title": "Unit tests on target"
        }, 
        {
            "location": "/guide/testing/#conclusions-and-outlook", 
            "text": "xpcc has a varity of testing strategies in place, is being used on a regular basis by Roboterclub Aachen e. V., receives updates and bug fixes frequently and test coverage is constantly improved.", 
            "title": "Conclusions and Outlook"
        }, 
        {
            "location": "/reference/api/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nAPI reference\n#\n\n\nxpcc is a relatively large framework with many APIs and advanced concepts.\nWe are annotating our APIs using Doxygen and are trying to provide conceptual\ndesign documentation on \nour project blog\n.\nHowever, this is a slow and difficult process, and the results are not perfect.\n\n\nThe most complete and most up-to-date API documentation is definitely the\n\n\n\n\nDoxygen API reference\n.\n\n\n\n\nUnfortunately the generated HAL for our many devices confuses Doxygen.\nWe therefore chose to only include the HAL API for \nATtiny85\n, the \nATmega328p\n\nand the \nSTM32F407vg\n online.\nThe rest of the xpcc API is documented without limitations.\n\n\n\n\n\nIf you are stuck, don't hesitate to \nsend us an email with your questions\n.", 
            "title": "API reference"
        }, 
        {
            "location": "/reference/api/#api-reference", 
            "text": "xpcc is a relatively large framework with many APIs and advanced concepts.\nWe are annotating our APIs using Doxygen and are trying to provide conceptual\ndesign documentation on  our project blog .\nHowever, this is a slow and difficult process, and the results are not perfect.  The most complete and most up-to-date API documentation is definitely the   Doxygen API reference .   Unfortunately the generated HAL for our many devices confuses Doxygen.\nWe therefore chose to only include the HAL API for  ATtiny85 , the  ATmega328p \nand the  STM32F407vg  online.\nThe rest of the xpcc API is documented without limitations.   If you are stuck, don't hesitate to  send us an email with your questions .", 
            "title": "API reference"
        }, 
        {
            "location": "/reference/build-system/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nBuild system\n#\n\n\nxpcc uses the \nSCons build system\n to generate, build and program your application.\nWe've extended it with many utilities to allow a smooth integration of embedded tools.\n\n\nBuild commands\n#\n\n\nYou can use these command in all our examples to get a feel of how it works.\n\n\nCommon\n#\n\n\n\n\nbuild\n: Generates the HAL and compiles your program into an executable.\n\n\nsize\n: Displays the static Flash and RAM consumption.\n\n\nprogram\n: Writes the executable onto your target.\n\n\n\n\n\nBy default \nscons\n executes \nscons build size\n.\n\n\n\n\nlisting\n: Decompiles your executable into an annotated assembly listing.\n\n\nsymbols\n: Displays the symbol table for your executable.\n\n\n-c\n: Cleans the project's build files.\n\n\nverbose=1\n: Makes the printout more verbose.\n\n\noptimization=[0,1,2,3,s]\n: Forces compilation with specified optimization level. Can be used for debug builds.\n\n\n\n\nAVR only:\n#\n\n\n\n\nfuse\n: Writes the fuse bits onto your target.\n\n\neeprom\n: Writes the EEPROM memory onto your target.\n\n\n\n\nARM Cortex-M only:\n#\n\n\n\n\ndebug\n: Starts the GDB debug session of your current application in text UI mode.\n\n           You must execute \nopenocd-debug\n or \nlpclink-debug\n before running this command!\n\n\nopenocd-debug\n: Starts the OpenOCD debug server for your target.\n\n\nlpclink-debug\n: Starts the LPC-Link debug server for your target.\n\n\nlpclink-init\n: Initialize the LPC-Link with its proprietary firmware.\n\n\n\n\nProject configuration\n#\n\n\nYour \nproject.cfg\n file contains configuration information for your target.\nFor the device identify naming scheme, see the \nDevice File reference\n.\n\n\n[build]\n\n\n# use a predefined board config file from xpcc/architecture/platform/board/\n\n\n# it defines the configuration for a board, which you can overwrite here.\n\n\nboard\n \n=\n \nstm32f4_discovery\n\n\n\n# declare the name of your project. Default is enclosing folder name.\n\n\nname\n \n=\n \nblinky\n\n\n# the target of your project, use the full name of the device here\n\n\ndevice\n \n=\n \nstm32f407vg\n\n\n# AVR only: declare the clock frequency in Hz\n\n\nclock\n \n=\n \n16000000\n\n\n# overwrite the default `./build/` folder path\n\n\nbuildpath\n \n=\n \n../../build/${name}\n\n\n# optimization level for compilation [0,1,2,3,s]\n\n\noptimization\n \n=\n \n0\n\n\n# declare additional compilation flags for your project\n\n\nccflags\n \n=\n \n-Werror -Wall -Wextra\n\n\n\n# parametrize HAL drivers here, see section on Parameters\n\n\n[parameters]\n\n\nuart.stm32.3.tx_buffer\n \n=\n \n2048\n\n\nuart.stm32.3.rx_buffer\n \n=\n \n256\n\n\n\n# AVR only: declare fuse bits for use with  $ scons fuse\n\n\n[fusebits]\n\n\n# only the fuses declared here are written\n\n\nefuse\n \n=\n \n0x41\n\n\nhfuse\n \n=\n \n0x42\n\n\nlfuse\n \n=\n \n0x43\n\n\n\n# AVR only: configure avrdude for  $ scons program\n\n\n# Consult the avrdude documentation for options.\n\n\n[avrdude]\n\n\n# using the AVR ISP mk2 programmer\n\n\nport\n \n=\n \nusb\n\n\nprogrammer\n \n=\n \navrispmkII\n\n\n# or using a serial bootloader\n\n\nport\n \n=\n \n/dev/ttyUSB0\n\n\nprogrammer\n \n=\n \narduino\n\n\n# baudrate only required for serial bootloaders\n\n\nbaudrate\n \n=\n \n115200\n\n\n\n# ARM only: configure OpenOCD for  $ scons program\n\n\n[openocd]\n\n\n# OpenOCD has predefined configs in its searchpaths\n\n\nconfigfile\n \n=\n \nboard/stm32f4discovery.cfg\n\n\n# but you can also use your own special config file\n\n\nconfigfile\n \n=\n \nopenocd.cfg\n\n\n# the commands to run on  $ scons program. Defaults are:\n\n\ncommands\n \n=\n\n\n    init\n\n\n    reset halt\n\n\n    flash write_image erase $SOURCE\n\n\n    reset run\n\n\n    shutdown\n\n\n\n# ARM only: configure Black Magic Probe for  $ scons program\n\n\n[black_magic_probe]\n\n\n# using a serial port\n\n\nport\n \n=\n \n/dev/ttyUSB0\n\n\n\n# LPC targets with LPC-Linkv2 programmer only\n\n\n[lpclink]\n\n\n# base path of the lpcxpresso installation\n\n\n# Default on Linux: /opt/lpcxpresso/\n\n\n# Default on OS X: /Applications/lcpxpresso_*/ (first match)\n\n\nbasepath\n \n=\n \n../lpcxpresso\n\n\n\n\n\n\nParameters\n#\n\n\nIn order to customize drivers further, driver parameters may be declared.\nThese follow the naming scheme \ntype.name.instance.parameter\n and are restrictive in the values they accept. Here is an overview of the available parameters.\n\n\nSet the software queue size for CAN messages for peripheral instance \nN\n in addition to the hardware queues:\n\n\n\n\ncan.stm32.N.tx_buffer \u2208 [0,254] = 32\n\n\ncan.stm32.N.rx_buffer \u2208 [0,254] = 32\n\n\n\n\nSets the main stack size. Note that the linkerscript may increase this to satisfy alignment requirements, especially with the vector table mapped to RAM. Default size is \n3kB - 32B\n.\n\n\n\n\ncore.cortex.0.main_stack_size \u2208 [512, 8192] = 3040\n\n\n\n\nPlaces the vector table in RAM. When your stack and interrupt vector table reside in the \nsame\n RAM section, this will \nincrease\n interrupt response time! The default setting is the fastest setting.\n\n\n\n\ncore.cortex.0.vector_table_in_ram \u2208 bool = false (true on STM32F3/STM32F7)\n\n\n\n\nEnables the blinking LED inside the hard fault handler.\nUse this feature to easily identify a crashed processor!\n\n\n\n\ncore.cortex.0.enable_hardfault_handler_led \u2208 bool = false\n\n\ncore.cortex.0.hardfault_handler_led_port \u2208 {A,B,C,D,E,F,G,H,I,J,K}\n\n\ncore.cortex.0.hardfault_handler_led_pin \u2208 [0,15]\n\n\n\n\nEnables the serial logger inside the hard fault handler.\nUse \nbasic\n for a minimal failure trace or \ntrue\n for a complete trace.\nYou must provide the peripheral instance of the used serial port as well as a \nXPCC_LOG_ERROR\n output stream!\n\n\n\n\ncore.cortex.0.enable_hardfault_handler_log \u2208 {false,basic,true} = false\n\n\ncore.cortex.0.hardfault_handler_uart \u2208 [1,8]\n\n\n\n\nSets the size of the transaction buffer for peripheral instance \nN\n.\nIncrease this if you have many connected I2C slaves.\n\n\n\n\ni2c.stm32.N.transaction_buffer \u2208 [1,100] = 8\n\n\n\n\nForces the SPI driver on AVRs to poll for transfer completion rather than to delegate execution back to the main loop. Enabling this only makes sense for very high SPI frequencies.\n\n\n\n\nspi.at90_tiny_mega.0.busywait \u2208 bool = false\n\n\n\n\nSet the software buffer for UART data for peripheral instance \nN\n.\nThe size is limited on AVRs, due to atomicity requirements!\n\n\n\n\nuart.at90_tiny_mega.N.tx_buffer \u2208 [1,254] = 64\n\n\n\n\nuart.at90_tiny_mega.N.rx_buffer \u2208 [1,254] = 8\n\n\n\n\n\n\nuart.lpc.0.tx_buffer \u2208 [1,65534] = 250\n\n\n\n\n\n\nuart.lpc.0.rx_buffer \u2208 [1,65534] = 16\n\n\n\n\n\n\nuart.stm32.N.tx_buffer \u2208 [1,65534] = 250\n\n\n\n\nuart.stm32.N.rx_buffer \u2208 [1,65534] = 16", 
            "title": "Build system"
        }, 
        {
            "location": "/reference/build-system/#build-system", 
            "text": "xpcc uses the  SCons build system  to generate, build and program your application.\nWe've extended it with many utilities to allow a smooth integration of embedded tools.", 
            "title": "Build system"
        }, 
        {
            "location": "/reference/build-system/#build-commands", 
            "text": "You can use these command in all our examples to get a feel of how it works.", 
            "title": "Build commands"
        }, 
        {
            "location": "/reference/build-system/#common", 
            "text": "build : Generates the HAL and compiles your program into an executable.  size : Displays the static Flash and RAM consumption.  program : Writes the executable onto your target.   By default  scons  executes  scons build size .   listing : Decompiles your executable into an annotated assembly listing.  symbols : Displays the symbol table for your executable.  -c : Cleans the project's build files.  verbose=1 : Makes the printout more verbose.  optimization=[0,1,2,3,s] : Forces compilation with specified optimization level. Can be used for debug builds.", 
            "title": "Common"
        }, 
        {
            "location": "/reference/build-system/#avr-only", 
            "text": "fuse : Writes the fuse bits onto your target.  eeprom : Writes the EEPROM memory onto your target.", 
            "title": "AVR only:"
        }, 
        {
            "location": "/reference/build-system/#arm-cortex-m-only", 
            "text": "debug : Starts the GDB debug session of your current application in text UI mode. \n           You must execute  openocd-debug  or  lpclink-debug  before running this command!  openocd-debug : Starts the OpenOCD debug server for your target.  lpclink-debug : Starts the LPC-Link debug server for your target.  lpclink-init : Initialize the LPC-Link with its proprietary firmware.", 
            "title": "ARM Cortex-M only:"
        }, 
        {
            "location": "/reference/build-system/#project-configuration", 
            "text": "Your  project.cfg  file contains configuration information for your target.\nFor the device identify naming scheme, see the  Device File reference .  [build]  # use a predefined board config file from xpcc/architecture/platform/board/  # it defines the configuration for a board, which you can overwrite here.  board   =   stm32f4_discovery  # declare the name of your project. Default is enclosing folder name.  name   =   blinky  # the target of your project, use the full name of the device here  device   =   stm32f407vg  # AVR only: declare the clock frequency in Hz  clock   =   16000000  # overwrite the default `./build/` folder path  buildpath   =   ../../build/${name}  # optimization level for compilation [0,1,2,3,s]  optimization   =   0  # declare additional compilation flags for your project  ccflags   =   -Werror -Wall -Wextra  # parametrize HAL drivers here, see section on Parameters  [parameters]  uart.stm32.3.tx_buffer   =   2048  uart.stm32.3.rx_buffer   =   256  # AVR only: declare fuse bits for use with  $ scons fuse  [fusebits]  # only the fuses declared here are written  efuse   =   0x41  hfuse   =   0x42  lfuse   =   0x43  # AVR only: configure avrdude for  $ scons program  # Consult the avrdude documentation for options.  [avrdude]  # using the AVR ISP mk2 programmer  port   =   usb  programmer   =   avrispmkII  # or using a serial bootloader  port   =   /dev/ttyUSB0  programmer   =   arduino  # baudrate only required for serial bootloaders  baudrate   =   115200  # ARM only: configure OpenOCD for  $ scons program  [openocd]  # OpenOCD has predefined configs in its searchpaths  configfile   =   board/stm32f4discovery.cfg  # but you can also use your own special config file  configfile   =   openocd.cfg  # the commands to run on  $ scons program. Defaults are:  commands   =      init      reset halt      flash write_image erase $SOURCE      reset run      shutdown  # ARM only: configure Black Magic Probe for  $ scons program  [black_magic_probe]  # using a serial port  port   =   /dev/ttyUSB0  # LPC targets with LPC-Linkv2 programmer only  [lpclink]  # base path of the lpcxpresso installation  # Default on Linux: /opt/lpcxpresso/  # Default on OS X: /Applications/lcpxpresso_*/ (first match)  basepath   =   ../lpcxpresso", 
            "title": "Project configuration"
        }, 
        {
            "location": "/reference/build-system/#parameters", 
            "text": "In order to customize drivers further, driver parameters may be declared.\nThese follow the naming scheme  type.name.instance.parameter  and are restrictive in the values they accept. Here is an overview of the available parameters.  Set the software queue size for CAN messages for peripheral instance  N  in addition to the hardware queues:   can.stm32.N.tx_buffer \u2208 [0,254] = 32  can.stm32.N.rx_buffer \u2208 [0,254] = 32   Sets the main stack size. Note that the linkerscript may increase this to satisfy alignment requirements, especially with the vector table mapped to RAM. Default size is  3kB - 32B .   core.cortex.0.main_stack_size \u2208 [512, 8192] = 3040   Places the vector table in RAM. When your stack and interrupt vector table reside in the  same  RAM section, this will  increase  interrupt response time! The default setting is the fastest setting.   core.cortex.0.vector_table_in_ram \u2208 bool = false (true on STM32F3/STM32F7)   Enables the blinking LED inside the hard fault handler.\nUse this feature to easily identify a crashed processor!   core.cortex.0.enable_hardfault_handler_led \u2208 bool = false  core.cortex.0.hardfault_handler_led_port \u2208 {A,B,C,D,E,F,G,H,I,J,K}  core.cortex.0.hardfault_handler_led_pin \u2208 [0,15]   Enables the serial logger inside the hard fault handler.\nUse  basic  for a minimal failure trace or  true  for a complete trace.\nYou must provide the peripheral instance of the used serial port as well as a  XPCC_LOG_ERROR  output stream!   core.cortex.0.enable_hardfault_handler_log \u2208 {false,basic,true} = false  core.cortex.0.hardfault_handler_uart \u2208 [1,8]   Sets the size of the transaction buffer for peripheral instance  N .\nIncrease this if you have many connected I2C slaves.   i2c.stm32.N.transaction_buffer \u2208 [1,100] = 8   Forces the SPI driver on AVRs to poll for transfer completion rather than to delegate execution back to the main loop. Enabling this only makes sense for very high SPI frequencies.   spi.at90_tiny_mega.0.busywait \u2208 bool = false   Set the software buffer for UART data for peripheral instance  N .\nThe size is limited on AVRs, due to atomicity requirements!   uart.at90_tiny_mega.N.tx_buffer \u2208 [1,254] = 64   uart.at90_tiny_mega.N.rx_buffer \u2208 [1,254] = 8    uart.lpc.0.tx_buffer \u2208 [1,65534] = 250    uart.lpc.0.rx_buffer \u2208 [1,65534] = 16    uart.stm32.N.tx_buffer \u2208 [1,65534] = 250   uart.stm32.N.rx_buffer \u2208 [1,65534] = 16", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/device-files/", 
            "text": "img.latex-inline { vertical-align: middle; }\n\n\n\nsvg.diagram{display:block;font-family:'Ubuntu Mono';font-size:14px;text-align:center;stroke-linecap:round;stroke-width:1.5px;stroke:#000;fill:#000}.md\nsvg.diagram .opendot{fill:#FFF}.md\nsvg.diagram text{stroke:none}.md\n\n\n\nDevice Files\n#\n\n\nThe device file describes the device metadata and peripheral tree in XML.\nInformation from one device can be extracted by providing the device identifier.\n\n\nDevice Identifier\n#\n\n\nThe device identifier is the canonical representation of the device name within the device file.\nIt consists out of the following elements with examples for device names \nstm32f407vg\n and \natmega328p\n:\n\n\n\n\n\n\n\n\nElement\n\n\nSTM32\n\n\nAVR\n\n\n\n\n\n\n\n\n\n\nplatform\n\n\nstm32\n\n\navr\n\n\n\n\n\n\nfamily\n\n\nf4\n\n\natmega\n\n\n\n\n\n\nname\n\n\n407\n\n\n328\n\n\n\n\n\n\ntype\n\n\n\n\np\n\n\n\n\n\n\npin-id\n\n\nv\n\n\n\n\n\n\n\n\nsize-id\n\n\ng\n\n\n32\n\n\n\n\n\n\n\n\nNotice that type and pin-id have different interpretations on the STM32 and AVR platform, which reflects in the device file format.\n\n\nNaming Scheme\n#\n\n\nAll device files can be currently found in the \nxpcc/architecture/platform/devices/\n, with the naming schemes dependend on architecture.\nExamples include:\n\n\n\n\navr:\n\n\nAT90: \nat90\n + \nsizes-type\n\n\nat9032_64_128-can.xml\n for \nAT90CAN(32|64|128)\n\n\n\n\n\n\nATtiny, ATmega: \natmega\n + \nsizes-types\n\n\natmega48_88_168_328-a_none_p_pa.xml\n for \nATMEGA(48|88|169|328)(a|p|pa)?\n\n\n\n\n\n\nATxmega: \nxmega\n + \nsizes-package-types\n\n\nxmega64_128-a1-none_u.xml\n for \nATXMEGA(64|128)A1(U)?\n\n\n\n\n\n\n\n\n\n\nstm32:\n\n\nSTM32F: \nstm32f\n + \nnames-pins-sizes\n\n\nstm32f405_407_415_417-i_r_v_z-e_g.xml\n for \nSTM32F(405|407|415|417)(I|R|V|Z)(E|G)\n\n\n\n\n\n\n\n\n\n\n\n\nFile Format\n#\n\n\nThe device files encode information about one or several very similar devices using a tree representation.\nThe device tree root declares its device scope using OR'ed device identifier elements.\n\n\nHere is the \nATmega328\n device family as an example:\n\n\ndevice\n \nplatform=\navr\n \nfamily=\natmega\n \nname=\n48|88|168|328\n \nsize_id=\n4|8|16|32\n \ntype=\na|none|p|pa\n\n  ...\n\n/device\n\n\n\n\n\n\nThis looks very similar for the \nSTM32F407\n device family:\n\n\ndevice\n \nplatform=\nstm32\n \nfamily=\nf4\n \nname=\n405|407|415|417\n \npin_id=\ni|r|v|z\n \nsize_id=\ne|g\n\n  ...\n\n/device\n\n\n\n\n\n\nAvailable Elements\n#\n\n\nInside the device tag, the following elements describe the device:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nflash\n\n\nsize of available non-volatile memory in bytes\n\n\n\n\n\n\nram\n\n\nsize of available volatile memory in bytes\n\n\n\n\n\n\neeprom\n\n\nsize of available eeprom in bytes (avr-only)\n\n\n\n\n\n\nlinkerscript\n\n\nname of linkerscript (cortex-m-only)\n\n\n\n\n\n\ncore\n\n\nname of CPU core\n\n\n\n\n\n\nmcu\n\n\navrdude name of device (avr-only)\n\n\n\n\n\n\npin-count\n\n\nnumber of pins on device\n\n\n\n\n\n\nheader\n\n\nrequired device header(s)\n\n\n\n\n\n\ndefine\n\n\nrequired device define(s)\n\n\n\n\n\n\ndriver\n\n\na peripheral driver implementation\n\n\n\n\n\n\n\n\nFor example, all devices in the STM32F407 family have 192kB of RAM:\n\n\nram\n196608\n/ram\n\n\n\n\n\n\nHowever, each element may also declare its device scope by including device identifier attributes.\nTo distinguish filterable device identifier attributes from declaration attributes, they must be prefixed with \ndevice-\n.\n\n\nFor the ATmega328 family several RAM sizes exist depending on device name:\n\n\nram\n \ndevice-name=\n48\n512\n/ram\n\n\nram\n \ndevice-name=\n88|168\n1024\n/ram\n\n\nram\n \ndevice-name=\n328\n2048\n/ram\n\n\n\n\n\n\nYou are even able to use the value of these elements to further limit the scope of new elements.\n\n\nAn example of this can be seen in the core driver file (discussed later), which uses the core element as device-scope:\n\n\ntemplate\n \ncore=\ncortex-m3|cortex-m4|cortex-m4f\nhard_fault_handler.cpp.in\n/template\n\n\n\n\n\n\nAs the device file is declarative, the filtering engine will resolve all dependencies recursively and throw an error in case of unresolved elements or circular referencing.\n\n\nAvailable Drivers\n#\n\n\nThe driver elements link the device hardware peripheral with a software implementation, which are found in \nxpcc/architecture/platform/driver/\n.\nEach driver is divided into several hardware dependend implementations.\n\n\nA selection of the most important drivers are:\n\n\ndriver\n|-- adc\n|-- can\n|-- clock\n|-- fsmc\n|-- gpio\n|   |-- at90_tiny_mega\n|   |-- generic\n|   `-- stm32\n|-- i2c\n|-- spi\n|   |-- at90_tiny_mega\n|   |-- at90_tiny_mega_uart\n|   |-- generic\n|   |-- stm32\n|   `-- stm32_uart\n|-- timer\n`-- uart\n\n\n\n\n\nNotice the \ngeneric\n folders. These are available for all platforms and are automatically included.\n\n\nAlso, notice how there exist two implementations for \nspi\n for the \nstm32\n and \nat90_tiny_mega\n platform.\nOne is for using the dedicated SPI hardware, and the other is for the UART hardware in SPI mode, however, both conform to the same SPI interface:\n\n\ndriver\n \ntype=\nspi\n \nname=\nstm32\n \ninstances=\n1,2,3\n/\n\n\ndriver\n \ntype=\nspi\n \nname=\nstm32_uart\n \ninstances=\n1,2,3,4,5,6\n/\n\n\n\n\n\n\nOf course, drivers may also declare device scope. For the STM32F407 family, the FSMC is not available for pin-id \nR\n (=64 pins):\n\n\ndriver\n \ndevice-pin-id=\ni|v|z\n \ntype=\nfsmc\n \nname=\nstm32\n/\n\n\n\n\n\n\nAny childen of a driver element will be available inside the driver instance template. Except for the reserved name \nparameter\n, there are no limitations on data structure or naming.\n\n\nFor example, the GPIO driver needs to know which pins are available for the requested device (with the \ngpio\n element), and what alternate functions to connect to them (with the \naf\n element).\n\n\nThis information is encoded as driver element children (here for the ATmega328 device family):\n\n\ndriver\n \ntype=\ngpio\n \nname=\nat90_tiny_mega\n\n  \ngpio\n \nport=\nB\n \nid=\n0\n \npcint=\n0\n/\n\n  ...\n  \ngpio\n \nport=\nD\n \nid=\n1\n \npcint=\n17\n\n    \naf\n \nperipheral=\nUart0\n \ntype=\nout\n \nname=\nTxd\n/\n\n  \n/gpio\n\n  \ngpio\n \nport=\nD\n \nid=\n2\n \npcint=\n18\n \nextint=\n0\n/\n\n  ...\n\n/driver\n\n\n\n\n\n\nOf course, device scope may also be declared for individual pins and even alternate functions (here for the STM32F407 device family):\n\n\ndriver\n \ntype=\ngpio\n \nname=\nstm32\n\n  ...\n  \ngpio\n \ndevice-pin-id=\ni|v|z\n \nport=\nE\n \nid=\n1\n\n    \naf\n \nid=\n12\n \nperipheral=\nFsmc\n \nname=\nNbl1\n/\n\n  \n/gpio\n\n  \ngpio\n \ndevice-pin-id=\ni|v|z\n \nport=\nE\n \nid=\n2\n\n    \naf\n \nid=\n12\n \nperipheral=\nFsmc\n \nname=\nA23\n/\n\n  \n/gpio\n\n  \ngpio\n \ndevice-pin-id=\ni|v|z\n \nport=\nE\n \nid=\n3\n\n    \naf\n \nid=\n12\n \nperipheral=\nFsmc\n \nname=\nA19\n/\n\n  \n/gpio\n\n  \ngpio\n \ndevice-pin-id=\ni|v|z\n \nport=\nE\n \nid=\n4\n\n    \naf\n \nid=\n12\n \nperipheral=\nFsmc\n \nname=\nA20\n/\n\n  \n/gpio\n\n  ...\n\n/driver\n\n\n\n\n\n\nThis structure is then available as a dictionary inside the device driver template files.\n\n\nDriver Files\n#\n\n\nThe device file only describes which folder contains the driver implementation and metadata for its implementation.\nIt does not specify which files are part of the implementation, and how multiple instances of a driver are created.\n\n\nThis is done using the \ndriver.xml\n file inside each driver implemenation.\nFor the \nat90_tiny_mega\n GPIO driver it contains:\n\n\ndriver\n \ntype=\ngpio\n \nname=\nat90_tiny_mega\n\n    \nstatic\ngpio_define.h\n/static\n\n    \ntemplate\ngpio.hpp.in\n/template\n\n    ...\n\n/driver\n\n\n\n\n\n\nHere the elements stand for:\n\n\n\n\nstatic\n: copy source file without modification,\n\n\ntemplate\n: generate source file \ngpio.hpp\n from \ngpio.hpp.in\n template with the device file GPIO data\n\n\n\n\nLet's look at how to generate several driver instances using a driver file.\nHere is the \nat90_tiny_meta\n UART driver file:\n\n\ndriver\n \ntype=\nuart\n \nname=\nat90_tiny_mega\n\n    \ntemplate\n \ninstances=\n0,1,2,3\n \nout=\nuart{{id}}.hpp\nuart.hpp.in\n/template\n\n    ...\n\n/driver\n\n\n\n\n\n\nHere the driver file has the capability to generate the instances 0,1,2 and 3 of the UART classes, and write them into the format specified by the \nout\n attribute.\nThe \ninstances\n attribute can be used to generate different instances out of different template files as shown in the \nstm32\n UART driver file:\n\n\ndriver\n \ntype=\nuart\n \nname=\nstm32\n\n    \ntemplate\n \ninstances=\n1,2,3,6\n \nout=\nusart_{{id}}.hpp\nuart.hpp.in\n/template\n\n    \ntemplate\n \ninstances=\n4,5\n \nout=\nuart_{{id}}.hpp\nuart.hpp.in\n/template\n\n    ...\n\n/driver\n\n\n\n\n\n\nNote, that only the instances declared in the device file will actually be generated!\n\n\nSo for the ATmega328, only UART instance 0 will be generated, since that has been declared in the device file:\n\n\ndriver\n \ntype=\nuart\n \nname=\nat90_tiny_mega\n \ninstances=\n0\n/\n\n\n\n\n\n\nCustom elements\n#\n\n\nIn the driver file, custom device-scoped elements may be declared, as in the \nat90_tiny_mega\n GPIO driver file:\n\n\ndriver\n \ntype=\ngpio\n \nname=\nat90_tiny_mega\n\n    ...\n    \nnotoggle\n \ndevice-family=\natmega\n \ndevice-name=\n8|16|32|64|128|162|8515|8535\nTrue\n/notoggle\n\n    \nnotoggle\n \ndevice-family=\nattiny\n \ndevice-name=\n26\nTrue\n/notoggle\n\n    ...\n\n/driver\n\n\n\n\n\n\nHere the \nnotoggle\n element will be added to the substitution dictionary only for the specified devices.\n\n\nParameters\n#\n\n\nIn order to customize drivers further parameters may be declared.\nThere are currently three types available:\n\n\n\n\nint\n: has a minimum and a maximum value\n\n\nbool\n: true/false\n\n\nenum\n: semicolon-separated values\n\n\n\n\nAll buffered UART implementations have two parameters named \ntx_buffer\n and \nrx_buffer\n, which are of type \nint\n and set the size of the atomic transmit and receive buffer.\n\n\ndriver\n \ntype=\nuart\n \nname=\nat90_tiny_mega\n\n    ...\n    \nparameter\n \nname=\ntx_buffer\n \ntype=\nint\n \nmin=\n1\n \nmax=\n254\n8\n/parameter\n\n    \nparameter\n \nname=\nrx_buffer\n \ntype=\nint\n \nmin=\n1\n \nmax=\n254\n4\n/parameter\n\n\n/driver\n\n\n\n\n\n\nEach UART instance receives their own two independent parameters with these default values.\n\n\nThe \nstm32\n core driver features the other two types:\n\n\ndriver\n \ntype=\ncore\n \nname=\ncortex\n\n    \nparameter\n \nname=\nallocator\n \ntype=\nenum\n \nvalues=\nnewlib;block_allocator\n\n        block_allocator\n    \n/parameter\n\n    \nparameter\n \nname=\nenable_gpio\n \ntype=\nbool\ntrue\n/parameter\n\n    ...\n\n/driver\n\n\n\n\n\n\nThese parameter may be overwritten in either the device file, or in the \nproject.cfg\n in the section \n[parameters]\n, which follows the naming scheme \ntype.name.instance.parameter\n:\n\n\n[\nparameters\n]\n\n\nuart\n.\nat90_tiny_mega\n.\n0.\ntx_buffer\n \n=\n \n200\n\n\nuart\n.\nat90_tiny_mega\n.\n0.\nrx_buffer\n \n=\n \n100\n\n\n\n\n\n\nGenerator\n#\n\n\nWe designed the device file format to use this form of XML to not only be human readable, but much more important, to be human-writeable.\n\n\nWe decided to group multiple devices of the same functionality family into one device file, instead of providing one device file for each of these devices.\n\n\nThis made accessing the devices files computationally more complex, since we have to evaluate the device-scope, however, it dramatically reduces redundancies and allows a much more natural description of devices in this language.\n\n\nWhile the first device files were still written manually, a device file generator soon became necessary to allow inclusion of many devices and to help with refactoring during API changes.\n\n\nThis generator uses multiple manufacturer provided description files to extract data about multiple devices and compress them into one device file, while preserving readability and correctness.\n\n\nFurther information about the device file generator can be found in the Readme at \n/tools/device_file_generator\n.", 
            "title": "Device files"
        }, 
        {
            "location": "/reference/device-files/#device-files", 
            "text": "The device file describes the device metadata and peripheral tree in XML.\nInformation from one device can be extracted by providing the device identifier.", 
            "title": "Device Files"
        }, 
        {
            "location": "/reference/device-files/#device-identifier", 
            "text": "The device identifier is the canonical representation of the device name within the device file.\nIt consists out of the following elements with examples for device names  stm32f407vg  and  atmega328p :     Element  STM32  AVR      platform  stm32  avr    family  f4  atmega    name  407  328    type   p    pin-id  v     size-id  g  32     Notice that type and pin-id have different interpretations on the STM32 and AVR platform, which reflects in the device file format.", 
            "title": "Device Identifier"
        }, 
        {
            "location": "/reference/device-files/#naming-scheme", 
            "text": "All device files can be currently found in the  xpcc/architecture/platform/devices/ , with the naming schemes dependend on architecture.\nExamples include:   avr:  AT90:  at90  +  sizes-type  at9032_64_128-can.xml  for  AT90CAN(32|64|128)    ATtiny, ATmega:  atmega  +  sizes-types  atmega48_88_168_328-a_none_p_pa.xml  for  ATMEGA(48|88|169|328)(a|p|pa)?    ATxmega:  xmega  +  sizes-package-types  xmega64_128-a1-none_u.xml  for  ATXMEGA(64|128)A1(U)?      stm32:  STM32F:  stm32f  +  names-pins-sizes  stm32f405_407_415_417-i_r_v_z-e_g.xml  for  STM32F(405|407|415|417)(I|R|V|Z)(E|G)", 
            "title": "Naming Scheme"
        }, 
        {
            "location": "/reference/device-files/#file-format", 
            "text": "The device files encode information about one or several very similar devices using a tree representation.\nThe device tree root declares its device scope using OR'ed device identifier elements.  Here is the  ATmega328  device family as an example:  device   platform= avr   family= atmega   name= 48|88|168|328   size_id= 4|8|16|32   type= a|none|p|pa \n  ... /device   This looks very similar for the  STM32F407  device family:  device   platform= stm32   family= f4   name= 405|407|415|417   pin_id= i|r|v|z   size_id= e|g \n  ... /device", 
            "title": "File Format"
        }, 
        {
            "location": "/reference/device-files/#available-elements", 
            "text": "Inside the device tag, the following elements describe the device:     Element  Description      flash  size of available non-volatile memory in bytes    ram  size of available volatile memory in bytes    eeprom  size of available eeprom in bytes (avr-only)    linkerscript  name of linkerscript (cortex-m-only)    core  name of CPU core    mcu  avrdude name of device (avr-only)    pin-count  number of pins on device    header  required device header(s)    define  required device define(s)    driver  a peripheral driver implementation     For example, all devices in the STM32F407 family have 192kB of RAM:  ram 196608 /ram   However, each element may also declare its device scope by including device identifier attributes.\nTo distinguish filterable device identifier attributes from declaration attributes, they must be prefixed with  device- .  For the ATmega328 family several RAM sizes exist depending on device name:  ram   device-name= 48 512 /ram  ram   device-name= 88|168 1024 /ram  ram   device-name= 328 2048 /ram   You are even able to use the value of these elements to further limit the scope of new elements.  An example of this can be seen in the core driver file (discussed later), which uses the core element as device-scope:  template   core= cortex-m3|cortex-m4|cortex-m4f hard_fault_handler.cpp.in /template   As the device file is declarative, the filtering engine will resolve all dependencies recursively and throw an error in case of unresolved elements or circular referencing.", 
            "title": "Available Elements"
        }, 
        {
            "location": "/reference/device-files/#available-drivers", 
            "text": "The driver elements link the device hardware peripheral with a software implementation, which are found in  xpcc/architecture/platform/driver/ .\nEach driver is divided into several hardware dependend implementations.  A selection of the most important drivers are:  driver\n|-- adc\n|-- can\n|-- clock\n|-- fsmc\n|-- gpio\n|   |-- at90_tiny_mega\n|   |-- generic\n|   `-- stm32\n|-- i2c\n|-- spi\n|   |-- at90_tiny_mega\n|   |-- at90_tiny_mega_uart\n|   |-- generic\n|   |-- stm32\n|   `-- stm32_uart\n|-- timer\n`-- uart  Notice the  generic  folders. These are available for all platforms and are automatically included.  Also, notice how there exist two implementations for  spi  for the  stm32  and  at90_tiny_mega  platform.\nOne is for using the dedicated SPI hardware, and the other is for the UART hardware in SPI mode, however, both conform to the same SPI interface:  driver   type= spi   name= stm32   instances= 1,2,3 /  driver   type= spi   name= stm32_uart   instances= 1,2,3,4,5,6 /   Of course, drivers may also declare device scope. For the STM32F407 family, the FSMC is not available for pin-id  R  (=64 pins):  driver   device-pin-id= i|v|z   type= fsmc   name= stm32 /   Any childen of a driver element will be available inside the driver instance template. Except for the reserved name  parameter , there are no limitations on data structure or naming.  For example, the GPIO driver needs to know which pins are available for the requested device (with the  gpio  element), and what alternate functions to connect to them (with the  af  element).  This information is encoded as driver element children (here for the ATmega328 device family):  driver   type= gpio   name= at90_tiny_mega \n   gpio   port= B   id= 0   pcint= 0 / \n  ...\n   gpio   port= D   id= 1   pcint= 17 \n     af   peripheral= Uart0   type= out   name= Txd / \n   /gpio \n   gpio   port= D   id= 2   pcint= 18   extint= 0 / \n  ... /driver   Of course, device scope may also be declared for individual pins and even alternate functions (here for the STM32F407 device family):  driver   type= gpio   name= stm32 \n  ...\n   gpio   device-pin-id= i|v|z   port= E   id= 1 \n     af   id= 12   peripheral= Fsmc   name= Nbl1 / \n   /gpio \n   gpio   device-pin-id= i|v|z   port= E   id= 2 \n     af   id= 12   peripheral= Fsmc   name= A23 / \n   /gpio \n   gpio   device-pin-id= i|v|z   port= E   id= 3 \n     af   id= 12   peripheral= Fsmc   name= A19 / \n   /gpio \n   gpio   device-pin-id= i|v|z   port= E   id= 4 \n     af   id= 12   peripheral= Fsmc   name= A20 / \n   /gpio \n  ... /driver   This structure is then available as a dictionary inside the device driver template files.", 
            "title": "Available Drivers"
        }, 
        {
            "location": "/reference/device-files/#driver-files", 
            "text": "The device file only describes which folder contains the driver implementation and metadata for its implementation.\nIt does not specify which files are part of the implementation, and how multiple instances of a driver are created.  This is done using the  driver.xml  file inside each driver implemenation.\nFor the  at90_tiny_mega  GPIO driver it contains:  driver   type= gpio   name= at90_tiny_mega \n     static gpio_define.h /static \n     template gpio.hpp.in /template \n    ... /driver   Here the elements stand for:   static : copy source file without modification,  template : generate source file  gpio.hpp  from  gpio.hpp.in  template with the device file GPIO data   Let's look at how to generate several driver instances using a driver file.\nHere is the  at90_tiny_meta  UART driver file:  driver   type= uart   name= at90_tiny_mega \n     template   instances= 0,1,2,3   out= uart{{id}}.hpp uart.hpp.in /template \n    ... /driver   Here the driver file has the capability to generate the instances 0,1,2 and 3 of the UART classes, and write them into the format specified by the  out  attribute.\nThe  instances  attribute can be used to generate different instances out of different template files as shown in the  stm32  UART driver file:  driver   type= uart   name= stm32 \n     template   instances= 1,2,3,6   out= usart_{{id}}.hpp uart.hpp.in /template \n     template   instances= 4,5   out= uart_{{id}}.hpp uart.hpp.in /template \n    ... /driver   Note, that only the instances declared in the device file will actually be generated!  So for the ATmega328, only UART instance 0 will be generated, since that has been declared in the device file:  driver   type= uart   name= at90_tiny_mega   instances= 0 /", 
            "title": "Driver Files"
        }, 
        {
            "location": "/reference/device-files/#custom-elements", 
            "text": "In the driver file, custom device-scoped elements may be declared, as in the  at90_tiny_mega  GPIO driver file:  driver   type= gpio   name= at90_tiny_mega \n    ...\n     notoggle   device-family= atmega   device-name= 8|16|32|64|128|162|8515|8535 True /notoggle \n     notoggle   device-family= attiny   device-name= 26 True /notoggle \n    ... /driver   Here the  notoggle  element will be added to the substitution dictionary only for the specified devices.", 
            "title": "Custom elements"
        }, 
        {
            "location": "/reference/device-files/#parameters", 
            "text": "In order to customize drivers further parameters may be declared.\nThere are currently three types available:   int : has a minimum and a maximum value  bool : true/false  enum : semicolon-separated values   All buffered UART implementations have two parameters named  tx_buffer  and  rx_buffer , which are of type  int  and set the size of the atomic transmit and receive buffer.  driver   type= uart   name= at90_tiny_mega \n    ...\n     parameter   name= tx_buffer   type= int   min= 1   max= 254 8 /parameter \n     parameter   name= rx_buffer   type= int   min= 1   max= 254 4 /parameter  /driver   Each UART instance receives their own two independent parameters with these default values.  The  stm32  core driver features the other two types:  driver   type= core   name= cortex \n     parameter   name= allocator   type= enum   values= newlib;block_allocator \n        block_allocator\n     /parameter \n     parameter   name= enable_gpio   type= bool true /parameter \n    ... /driver   These parameter may be overwritten in either the device file, or in the  project.cfg  in the section  [parameters] , which follows the naming scheme  type.name.instance.parameter :  [ parameters ]  uart . at90_tiny_mega . 0. tx_buffer   =   200  uart . at90_tiny_mega . 0. rx_buffer   =   100", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/device-files/#generator", 
            "text": "We designed the device file format to use this form of XML to not only be human readable, but much more important, to be human-writeable.  We decided to group multiple devices of the same functionality family into one device file, instead of providing one device file for each of these devices.  This made accessing the devices files computationally more complex, since we have to evaluate the device-scope, however, it dramatically reduces redundancies and allows a much more natural description of devices in this language.  While the first device files were still written manually, a device file generator soon became necessary to allow inclusion of many devices and to help with refactoring during API changes.  This generator uses multiple manufacturer provided description files to extract data about multiple devices and compress them into one device file, while preserving readability and correctness.  Further information about the device file generator can be found in the Readme at  /tools/device_file_generator .", 
            "title": "Generator"
        }
    ]
}